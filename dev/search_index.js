var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"examples/#Construction","page":"Examples","title":"Construction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package provides several  types to represent  polynomials relative  to different  bases from the standard polynomial  basis, 1,x,x², x³ etc.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, the Legendre polynomials are a collection of polynomials on [-1,1]. The first few may be seen through:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials\n\njulia> p0 = Legendre([1])\nLegendre(1⋅P₀(x))\n\njulia> p1 = Legendre([0,1])\nLegendre(1⋅P₁(x))\n\njulia> p2 = Legendre([0,0,1])\nLegendre(1⋅P₂(x))\n\njulia> p3 = Legendre([0,0,0,1])\nLegendre(1⋅P₃(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A plot recipe is useful for a graphical view:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials  # hide\nn = 6\nψ₁, ψ₂, ψ₃, ψ₄, ψ₅, ψ₆ = basis.(Legendre, 0:n - 1)\nkw = (xlabel=\"r\", ylabel=\"ψₙ(r)\")\nsps = [\n  plot( ψ₁, label=\"ψ₁(r)\"; kw...),\n  plot( ψ₂, label=\"ψ₂(r)\"; kw...),\n  plot( ψ₃, label=\"ψ₃(r)\"; kw...),\n  plot( ψ₄, label=\"ψ₄(r)\"; kw...),\n  plot( ψ₅, label=\"ψ₅(r)\"; kw...),\n  plot( ψ₆, label=\"ψ₆(r)\"; kw...),\n]\nplot(sps..., layout=(3, 2))\nshow(current())  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The coefficients, e.g., [0,0,0,1] indicate a polynomial 0⋅p0 + 0⋅p1 + 0⋅p2 + 1⋅p3. The show method expresses these polynomials relative to their bases. More familiar expressions are seen by conversion to the standard basis. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> convert.(Polynomial, [p0,p1,p2,p3])\n4-element Vector{Polynomial{Float64, :x}}:\n Polynomials.Polynomial(1.0)\n Polynomials.Polynomial(1.0*x)\n Polynomials.Polynomial(-0.5 + 1.5*x^2)\n Polynomials.Polynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Polynomial instances are callable. We have, for example, to evaluate a polynomial at a set of points:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p3.([1/4, 1/2, 3/4])\n3-element Vector{Float64}:\n -0.3359375\n -0.4375\n -0.0703125","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Conversion can also be achieved through polynomial evaluation, using a variable x in the Polynomial basis:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> x = variable(Polynomial)\nPolynomials.Polynomial(1.0*x)\n\njulia> p3(x)\nPolynomials.Polynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Representation in another basis can be achieved this way:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> u = variable(ChebyshevU)\nChebyshevU(0.5⋅U₁(x))\n\njulia> p3(u)\nChebyshevU(- 0.125⋅U₁(x) + 0.3125⋅U₃(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For most of the orthogonal polynomials, a conversion from the standard basis is provided, and a conversion between different parameter values  for the  same polynomial type are provided. Conversion methods between other polynomial types are not provided, but either evaluation, as above, or conversion through the Polynomial type is possible. As possible, for the orthogonal polynomial types, conversion utilizes the FastTransforms package; this package can handle conversion between polynomials with very high degree.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the basis functions, the basis function can be used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> h0,h1,h2,h3 = basis.(Hermite, 0:3);\n\njulia> x = variable();\n\njulia> h3(x)\nPolynomials.Polynomial(-12.0*x + 8.0*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For numeric evaluation of just a basis polynomial of a classical orthogonal polynomial system, the Basis constructor provides a direct evaluation without the construction of an intermediate polynomial:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Basis(Hermite, 3)(0.5)\n-5.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If the coefficients of a polynomial relative to the polynomial type are known, they can be directly passed to the constructor:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Laguerre{0}([1,2,3])\ntypename(Laguerre){0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some polynomial types are parameterized, as above. The parameters are passed to the type, as in this example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Jacobi{1/2, -1/2}([1,2,3])\ntypename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The polynomial types specified above are orthogonal, meaning the inner product of different basis vectors will be 0. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using QuadGK\n\n\njulia> P = Legendre\nLegendre\n\njulia> p4,p5 = basis.(P, [4,5])\n2-element Vector{Legendre{Float64, :x}}:\n Legendre(1.0⋅P₄(x))\n Legendre(1.0⋅P₅(x))\n\njulia> wf, dom = SpecialPolynomials.weight_function(P), Polynomials.domain(P);\n\njulia> quadgk(x -> p4(x) * p5(x) *  wf(x), first(dom), last(dom))\n(0.0, 0.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The unexported innerproduct will compute this as well, without the need to specifiy the domain or weight function, which can be gleaned from the type.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SpecialPolynomials.innerproduct(P, p4, p5)\n-1.5309832087675112e-16","category":"page"},{"location":"examples/#Polynomial-methods","page":"Examples","title":"Polynomial methods","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For each polynomial type, this package implements as many of the methods for polynomials defined in Polynomials, as possible.","category":"page"},{"location":"examples/#Evaluation","page":"Examples","title":"Evaluation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Evalution, as seen, is done through making polynomial objects callable:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = Chebyshev\nChebyshev\n\njulia> p = P([1,2,3,4])\nChebyshev(1⋅T₀(x) + 2⋅T₁(x) + 3⋅T₂(x) + 4⋅T₃(x))\n\njulia> p(0.4)\n-4.016","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By default, for classical orthogonal polynomials,  the Clenshaw reduction formula is used. For such polynomials, an alternative is to use the hypergeometric formulation. (The evaluation Basis(P,n)(x) uses this.) There is an unexported method to compute through this means:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SpecialPolynomials.eval_hyper(P, coeffs(p),  0.4)\n-4.016","category":"page"},{"location":"examples/#Arithmetic","page":"Examples","title":"Arithmetic","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, basic arithmetic operations  are defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU\nChebyshevU\n\njulia> p,q = P([1,2,3,4]), P([-2,0,1,2])\n(ChebyshevU(1⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x)), ChebyshevU(- 2⋅U_0(x) + 1⋅U_2(x) + 2⋅U_3(x)))\n\njulia> p + 1\nChebyshevU(2⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x))\n\njulia> -p\nChebyshevU(- 1⋅U_0(x) - 2⋅U_1(x) - 3⋅U_2(x) - 4⋅U_3(x))\n\njulia> p + q\nChebyshevU(- 1⋅U_0(x) + 2⋅U_1(x) + 4⋅U_2(x) + 6⋅U_3(x))\n\njulia> p*q\nChebyshevU(9⋅U_0(x) + 8⋅U_1(x) + 10⋅U_2(x) + 6⋅U_3(x) + 15⋅U_4(x) + 10⋅U_5(x) + 8⋅U_6(x))\n\njulia> p^2\nChebyshevU(30⋅U_0(x) + 40⋅U_1(x) + 51⋅U_2(x) + 44⋅U_3(x) + 41⋅U_4(x) + 24⋅U_5(x) + 16⋅U_6(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multiplication formulas may not be defined for each type, and a fall back may be used where the multiplication is done with respect to the standard basis and the answer re-represented:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = Jacobi{1/2, -1/2}\nJacobi{0.5, -0.5}\n\njulia> p,q = P([1,2]), P([-2,1])\n(typename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), typename(Jacobi){0.5,-0.5}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))\n\njulia> p * q\ntypename(Jacobi){0.5,-0.5}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))","category":"page"},{"location":"examples/#Derivatives-and-integrals","page":"Examples","title":"Derivatives and integrals","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The classic continuous orthogonal polynomials  have  the derivative  and integrate methods defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU{Float64}\nChebyshevU{Float64}\n\njulia> p = P([1,2,3])\nChebyshevU(1.0⋅U₀(x) + 2.0⋅U₁(x) + 3.0⋅U₂(x))\n\njulia> dp = derivative(p)\nChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))\n\njulia> convert.(Polynomial, (p, dp))\n(Polynomials.Polynomial(-2.0 + 4.0*x + 12.0*x^2), Polynomials.Polynomial(4.0 + 24.0*x))\n\njulia> P = Jacobi{1//2, -1//2}\nJacobi{1//2, -1//2}\n\njulia> p,q = P([1,2]), P([-2,1])\n(typename(Jacobi){1//2,-1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), typename(Jacobi){1//2,-1//2}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))\n\njulia> p * q # as above, only with rationals for paramters\ntypename(Jacobi){1//2,-1//2}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))\n\njulia> P = Jacobi{1//2, 1//2}\nJacobi{1//2, 1//2}\n\njulia> p = P([1,2,3])\ntypename(Jacobi){1//2,1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))\n\njulia> dp = derivative(p)\ntypename(Jacobi){1//2,1//2}(3.0⋅Jᵅᵝ₀(x) + 10.0⋅Jᵅᵝ₁(x))\n\njulia> integrate(p)\ntypename(Jacobi){1//2,1//2}(0.24999999999999994⋅Jᵅᵝ₁(x) + 0.6⋅Jᵅᵝ₂(x) + 0.5714285714285714⋅Jᵅᵝ₃(x))\n\njulia> integrate(p, 0, 1)\n3.125","category":"page"},{"location":"examples/#Conversion","page":"Examples","title":"Conversion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Expressing a polynomial in type P in type Q is done through several possible means:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P,Q = Gegenbauer{1//3}, Gegenbauer{2//3}\n(Gegenbauer{1//3}, Gegenbauer{2//3})\n\njulia> p = P([1,2,3.0])\ntypename(Gegenbauer){1//3}(1.0⋅Cᵅ₀(x) + 2.0⋅Cᵅ₁(x) + 3.0⋅Cᵅ₂(x))\n\njulia> convert(Q, p)\ntypename(Gegenbauer){2//3}(0.8⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.2⋅Cᵅ₂(x))\n\njulia> p(variable(Q))\ntypename(Gegenbauer){2//3}(0.7999999999999999⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.1999999999999997⋅Cᵅ₂(x))\n\njulia> SpecialPolynomials._convert_cop(Q,p)\ntypename(Gegenbauer){2//3}(0.8⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.2⋅Cᵅ₂(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first uses a method from the FastTransforms package (when loaded). This package can handle polynomials of very high degree. It is used by default, as much as possible. The second uses polynomial evalution (Clenshaw evaluation) to perform the conversion. The third uses the structural equations for conversion, when possible, and defaults to converting through the Polynomial type","category":"page"},{"location":"examples/#Roots","page":"Examples","title":"Roots","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The roots function finds the roots of a polynomial","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p = Legendre([1,2,2,1])\nLegendre(1⋅P₀(x) + 2⋅P₁(x) + 2⋅P₂(x) + 1⋅P₃(x))\n\njulia> rts = roots(p); rts ≈ [-1, -1/5, 0]\ntrue\n\njulia> maximum(abs∘p, rts) <= 10eps() # small residual\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we see fromroots and roots are related, provided a monic polynomial is used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials; const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> P = Jacobi{1/2,-1/2}\nJacobi{0.5, -0.5}\n\n\njulia> p = P([1,1,2,3])\ntypename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x) + 2⋅Jᵅᵝ₂(x) + 3⋅Jᵅᵝ₃(x))\n\njulia> q = SP.monic(p) # monic is not exported\ntypename(Jacobi){0.5,-0.5}(0.13333333333333333⋅Jᵅᵝ₀(x) + 0.13333333333333333⋅Jᵅᵝ₁(x) + 0.26666666666666666⋅Jᵅᵝ₂(x) + 0.4⋅Jᵅᵝ₃(x))\n\njulia> fromroots(P, roots(q)) - q |> u -> truncate(u, atol=sqrt(eps()))\ntypename(Jacobi){0.5,-0.5}(0.0 + 0.0im)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For many of the orthogonal polynomials, the roots are found from the comrade matrix using a mathcalO(n^2) algorithm of Aurentz, Vandebril, and Watkins, which computes in a more efficient manner the eigvals(SpecialPolynomials.comrade_matrix(p)). Alternatively, in theory roots may be identified from the companion matrix of the polynomial, once expressed in the standard basis. This approach is the fallback approach for other polynomial types, but is prone to numeric issues.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For orthogonal polynomials, the roots of the basis vectors are important for quadrature. For larger values of n, the eigenvalues of the unexported jacobi_matrix also identify these roots, but the algorithm is more stable than conversion to the standard basis","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> round′(p) = map(x -> round(x, digits=6), p)\nround′ (generic function with 1 method)\n\njulia> p4 = basis(Legendre, 4)\nLegendre(1.0⋅P₄(x))\n\njulia> roots(p4) .|> real .|> round′\n4-element Vector{Float64}:\n -0.861136\n -0.339981\n  0.339981\n  0.861136\n\njulia> eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 4)) .|> x -> round(x, digits=10)\n4-element Vector{Float64}:\n -0.8611363116\n -0.3399810436\n  0.3399810436\n  0.8611363116","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"At higher degrees, the difference in  stability comes out. For the special case of a basis polynomial, we see this difference in the maximum residual:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> p50 = basis(Legendre{Float64}, 50)\nLegendre(1.0⋅P₅₀(x))\n\njulia> as = eigvals(Polynomials.companion(p50));\n\njulia> maximum(abs ∘ p50, as) < sqrt(eps())\nfalse\n\njulia> bs = eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 50 ));\n\njulia> maximum(abs ∘ p50, bs) < sqrt(eps())\ntrue\n\njulia> maximum(abs, roots(p50) - bs) < sqrt(eps())\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(The roots of the classic orthogonal polynomials  are  all  real  and distinct.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The unexported gauss_nodes_weights function returns the nodes and weights. For many types (e.g., Jacobi, Legendre, Hermite, Laguerre). As possible, it uses the methods from the FastGaussQuadratures package, which provides O(n) algorithms, where the Jacobi matrix is O(n²).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ws = SpecialPolynomials.gauss_nodes_weights(Legendre, 4)\n([-0.86113631159405, -0.33998104358485537, 0.33998104358485715, 0.8611363115940526], [0.34785484513745607, 0.6521451548625448, 0.652145154862546, 0.3478548451374536])\n\njulia> basis(Legendre, 4).(xs)\n4-element Vector{Float64}:\n -1.199040866595169e-14\n  1.6930901125533637e-15\n -1.6653345369377348e-15\n  1.1102230246251565e-16\n\njulia> f(x) = x^7 - x^6; F(x) = x^8/8 - x^7/7;\n\njulia> sum(f(x)*w for (x,w) in zip(xs, ws)) - (F(1) - F(-1))\n3.3306690738754696e-15","category":"page"},{"location":"examples/#Fitting","page":"Examples","title":"Fitting","text":"","category":"section"},{"location":"examples/#Interpolation","page":"Examples","title":"Interpolation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For any set of points (x0,y0), (x1,y1), ..., (xn, yn) with unique x values,  there is a unique polynomial of degree n or less that interpolates these points, that is  p(x_i) = y_i. The  fit function will perform polynomial interpolation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ys = [0, 1/4,  1/2,  3/4], [1,2,2,3]\n([0.0, 0.25, 0.5, 0.75], [1, 2, 2, 3])\n\njulia> p1 = fit(Polynomial,  xs, ys) |> round′\nPolynomials.Polynomial(1.0 + 8.666667*x - 24.0*x^2 + 21.333333*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Lagrange and Newton types represent the polynomial in convenient bases based on the nodes (xs):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p2 = fit(Lagrange, xs, ys)\nLagrange(1⋅ℓ_0(x) + 2⋅ℓ_1(x) + 2⋅ℓ_2(x) + 3⋅ℓ_3(x))\n\njulia> p3 = fit(Newton, xs, ys)\nNewton(1.0⋅p_0(x) + 4.0⋅p_1(x) - 8.0⋅p_2(x) + 21.333333333333332⋅p_3(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These all represent the same interpolating polynomial:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> [p1.(xs)-ys  p2.(xs)-ys p3.(xs)-ys]\n4×3 Matrix{Float64}:\n 0.0         0.0  0.0\n 7.8125e-8   0.0  0.0\n 1.25e-7     0.0  0.0\n 1.09375e-7  0.0  0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Lagrange and Newton  methods allow a function to be specified  in place  of a set of y values:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p = fit(Newton, [1,2,3], x->x^2)\nNewton(1.0⋅p_0(x) + 3.0⋅p_1(x) + 1.0⋅p_2(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(1.0*x^2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Polynomial interpolation can demonstrate the Runge phenomenon if the nodes are evenly spaced and n is large enough. For higher degree fitting, the choice of nodes can greatly effect the approximation of the interpolating polynomial to the function generating the y values. The SpecialPolynomials.lagrange_barycentric_nodes_weights function returns nodes (and accompanying weights) for different polynomial types.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For an orthogonal polynomial type, the zeros of the basis polynomial p_{n+1}, labeled x_0, x_1, ..., x_n are often used as nodes, especially for the Chebyshev nodes (of the first kind).  Gil, Segura, and Temme say \"Interpolation with Chebyshev nodes is not as good as the best approximation ..., but usually it is the best practical possibility for interpolation and certainly much better than equispaced interpolation\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, the default for fit for degree n will use the zeros of P_{n+1} to interpolate.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can see that some interpolation points lead to better fits than others, in the following graphic:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nf(x) = exp(-x)*sinpi(x)\nplot(f, -1, 1, legend=false, color=:black, linewidth=3)\np=fit(Val(:interpolating), Chebyshev, f, 3); plot!(p, color=:blue)\np=fit(Val(:interpolating), ChebyshevU, f, 3); plot!(p, color=:red)\nfit(Val(:interpolating), Legendre, f, 3); plot!(p, color=:green)\nxs = [-0.5, 0.0, 0.5]\np=fit(Newton, xs, f);\nts = range(-1, 1, length=100); plot!(ts, p.(ts), color=:brown)\nsavefig(\"fitting.svg\")  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Polynomial-approximation","page":"Examples","title":"Polynomial approximation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are other criteria for fitting that can be used.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If there are a lot of points, it is common  to  fit with a  lower  degree polynomial. This won't  be an interpolating polynomial, in general. The criteria  used to select the polynomial is  typically least squares (weighted least squares is also available). Fitting  ini the standard basis, a  degree  is specified, as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ys =  [1,2,3,4], [2.0,3,1,4]\n([1, 2, 3, 4], [2.0, 3.0, 1.0, 4.0])\n\njulia> p1 =  fit(Polynomial, xs,  ys, 1) |> round′ # degree 1  or less\nPolynomials.Polynomial(1.5 + 0.4*x)\n\njulia> p1 =  fit(Polynomial, xs,  ys, 2) |> round′ # degree 2 or less\nPolynomials.Polynomial(4.0 - 2.1*x + 0.5*x^2)\n\njulia> p1 =  fit(Polynomial, xs,  ys) |> round′    # degree 3 or less (length(xs) - 1)\nPolynomials.Polynomial(-10.0 + 20.166667*x - 9.5*x^2 + 1.333333*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, fitting a polynomial to a function using least squares can be solved using the polynomial a0⋅p0 + a1⋅p1 + ⋅⋅⋅ + an⋅pn where ai=∫f⋅pi⋅w⋅dx / ∫pi^2⋅w⋅dx. There is no need to specify values for x:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f(x) = exp(-x) * sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This wavy example is from Trefethen:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f(x) = sin(6x) + sin(60*exp(x))\nf (generic function with 1 method)\n\njulia> p50 = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p50(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps()) # cf. graph below\nfalse","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(With 50 points, the approximation misses badly over [-1,1]. There are 45 local extrema on  this interval.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"However, with more points we have a good fit:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p196 = fit(Chebyshev{Float64}, f, 196);\n\njulia> maximum(norm(p196(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())  # ≈ 1e-13\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nf(x) = sin(6x) + sin(60*exp(x))\np50 = fit(Chebyshev{Float64}, f, 50);\np196 = fit(Chebyshev{Float64}, f, 196);\nplot(f, -1, 1, legend=false, color=:black)\nxs = range(-1, stop=1, length=500) # more points than recipe\nplot!(xs, p50.(xs), color=:blue)\nplot!(xs, p196.(xs), color=:red)\nshow(current())  # hide\nsavefig(\"wavy.svg\")  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the  Chebyshev type, the  Val(:series) argument will fit a heuristically identify truncated series  to the function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Polynomials, SpecialPolynomials\nf(x) = sin(6x) + sin(60*exp(x))\np = fit(Val(:series), Chebyshev, f);\ndegree(p)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe ApproxFun package provides a framework to quickly and accuratately approximate functions using certain polynomial types. The choice of order and methods for most of Julia's built-in functions are conveniently provided.","category":"page"},{"location":"examples/#Plotting","page":"Examples","title":"Plotting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The plot recipe from the Polynomials package works as expected for the polynomial types in this package. The domain to be plotted over matches that given by Polynomials.domain, unless this is infinite.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A plot of the first few Chebyshev Polynomials of the second kind can be produced as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials  # hide\n# U1, U2, U3, and U4:\nchebs  = basis.(ChebyshevU, 1:4)\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\np = plot(legend=false)\nfor (cheb, col) in zip(chebs, colors)\n  plot!(p, cheb, c=col, lw=5)\nend\nsavefig(p, \"chebs.svg\")  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#SpecialPolynomials.jl","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Documentation for SpecialPolynomials.jl.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"CurrentModule = SpecialPolynomials","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"#Overview","page":"SpecialPolynomials.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"This package provides a number of different polynomial types to represent polynomials, extending the Polynomials package.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractSpecialPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractSpecialPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractSpecialPolynomial","text":"AbstractSpecialPolynomial{T,X}\n\nAn abstract type to distinguish the different polynomial types in this package.\n\nThe concrete types specify different bases for the space of polynomials of degree n or less.\n\nThis package includes:\n\nseveral classic orthogonal polynomials.\nNewton and Lagrange interpolating polynomials\nBernstein polynomials\n\nAs many of the methods for the base Polynomials class are directly coded if possible, but quite a few depend on conversion to the base Polynomial type (which uses the standard polynomial basis).\n\n\n\n\n\n","category":"type"},{"location":"#Orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractOrthogonalPolynomial\nSpecialPolynomials.AbstractCCOP\nSpecialPolynomials.AbstractCDOP","category":"page"},{"location":"#SpecialPolynomials.AbstractOrthogonalPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractOrthogonalPolynomial","text":"AbstractOrthogonalPolynomial{T,X}\n\nType to represent systems of orthogonal polynomials. These polynomials have  several properties, including an accompanying inner product satsifying  ⟨yᵢ, yⱼ⟩ = cᵢδᵢⱼ.\n\nIn addition to methods inherited from the underlying AbstractPolynomial  type, orthogonal polynomial  types may have methods   weight_function, generating_function, leading_term, norm2, jacobi_matrix, and gauss_nodes_weights,  though none are  exported.\n\nSubtypes of AbstractCOP <: AbstractOrthogonalPolynomial utilize the fact that the basis  polynomials  satisfy\n\n(ax² + bx + c)yᵢ''(x) + (dx+e)yᵢ'(x) + λᵢyᵢ(x) = 0 (or a discrete analogue)\n\nwhere the structural relations are functions of a,b,c,d,e. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the Polynomial type (the FallingFactorial type in the discrete  c case),\n\nA key structural relation is the three-term recursion,  yᵢ₊₁ =  (Aᵢx +  Bᵢ)yᵢ -  Cᵢyᵢ₋₁. For systems  specfied by  a  weight function, the  values of Aᵢ, Bᵢ, and Cᵢ can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the Polynomial  type throughe evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCCOP","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCCOP","text":"AbstractCCOP{T,X} <:  AbstractCOP{T,X}\n\nFollowing Koepf and Schmersau, a family y(x)=p_n(x)=k_x⋅x^n +  ... for  n  ∈  {0, 1,…}, k_n ≠ 0 of polynomials is a family of classic continuous orthogonal polynomials if each is  a solution of the differential equation\n\n(a⋅x²+b⋅x+c) ⋅ yᵢ'' + (d⋅x + e) ⋅ yᵢ' + λᵢ⋅ yᵢ = 0.\n\nA family is characterized, up to choice of leading term, by the 5 coefficients: a,b,c,d,e. Let σ = (a⋅x²+b⋅x+c), τ = (d⋅x + e).\n\nFrom these  5  coefficients several structural  equations are represented. For example the three-point recusion.\n\nP₍ᵢ₊₁₎ = (Aᵢ⋅x + Bᵢ) * Pᵢ - Cᵢ *  P₍ᵢ₋₁₎,\n\nwhere Aᵢ,Bᵢ,Cᵢ can be represented in formulas involving just  a,b,c,d,e and i.\n\nRearranging   gives the structural equation:\n\nx⋅p_n   = [an, bn, cn] ⋅ [p_{n+1}, p_n, p_{n-1}]  (Eqn (7))\n\nThe other structural equations are (equation  references are from Koepf and Schmersau):\n\nσ⋅p'_n  = [αn, βn, γn] ⋅  [p_{n+1}, p_n, p_{n-1}] (Eqn (9), n ≥ 1)\n\np_n = [ân, b̂n, ĉn]  ⋅  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn (19))\n\nx⋅p'_n  = [αᴵn, βᴵn, γᴵn] ⋅  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn  (14))\n\nUsing (7), Clenshaw polynomial evaluation using the three  point recursion is defined.\n\nUsing (19), expressions for derivatives are found.\n\nUsing  (19), expressions for integration are found (p7).\n\nUsing their theorems 2,4, and 5, connection coefficients, C(n,m) satisfying P_n(x) =  ∑  C(n,m)  Q_m(x) (n ≥ 0, 0 ≤  m ≤ n) are  found. These allow  fallback  definitions for convert(Polynomial,p),  convert(P, p::Polynomial), convert(P{α…}, p::P(β…)) and through composition polynomial  multiplication,  p*q.\n\nSubtypes of AbstractCCOP are  created through  the @register0 or  @registerN macros, where the  N  macro  is used  if parameters are  needed to describe the family.\n\nIf non-monic versions are desired, then the  leading  term can be  specified through kn() (which by default is defined by the  method k1k0(P,i), the ratio of  kᵢ₊₁/kᵢ).  The @register_monic macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the @register_shifted macro is useful  to provide shifted versions (cf. ShiftedLegendre).\n\nRegistering a system, defining an abcde method, and optionally defining k1k0 is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.\n\nThe defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. Chebyshev,ChebyshevU, Hermite, Laguerre), but not all.\n\nExample\n\nFor this example, the value of Bn at 0 needs help:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> SP.@register0 MonicLegendre′ SP.AbstractCCOP0\n\njulia> SP.:ϟ(::Type{<:MonicLegendre′}) = Legendre\n\njulia> SP.@register_monic MonicLegendre′  # use  ϟ to delegate methods\n\njulia> 𝐐  =  Rational{Int}\nRational{Int64}\n\njulia> x = variable(Polynomial{𝐐})\nPolynomials.Polynomial(x)\n\njulia> [basis(MonicLegendre′{𝐐}, i)(x) for i  in 0:5]\n6-element Vector{Polynomial{T, :x} where T}:\n Polynomials.Polynomial(1//1)\n Polynomials.Polynomial(1.0*x)\n Polynomials.Polynomial(-0.3333333333333333 + 1.0*x^2)\n Polynomials.Polynomial(-0.6*x + 1.0*x^3)\n Polynomials.Polynomial(0.0857142857142857 - 0.857142857142857*x^2 + 1.0*x^4)\n Polynomials.Polynomial(0.23809523809523805*x - 1.111111111111111*x^3 + 1.0*x^5)\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCDOP","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCDOP","text":" AbstractCDOP{T,X} <: AbstractCOP{T,X}\n\nFollowing Koepf  and Schmersau, a family y(x)=p_n(x)=k_x⋅x^n +  ... for  n  ∈  {0, 1,…}, k_n ≠ 0 of polynomials is a family of classic discrete orthogonal polynomials if it  is  a solution of a differential equation\n\n(a⋅x²+b⋅x+c) ⋅ Δ∇y + (d⋅x + e) ⋅ ∇' + λᵢ⋅ y = 0,\n\nwhere  Δy(x) = y(x+1) - y(x) and ∇y(x) = y(x) - y(x-1).\n\nA family is characterized by the 5 coefficients: a,b,c,d,e. Let σ = (a⋅x²+b⋅x+c), τ = (d⋅x + e).\n\nAs in the classical-continuous-orthogonal-polynomial case AbstractCCOP, from these 5 values the cofficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials.\n\nFor example, on p29 they give  formulas for Hahn polynomials through:\n\nn(n+α+β+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1),  with  explicit values  for  B and D. Reexpressing gives: BΔy(x) - D∇y(x) -λ y(x)  = 0. From the rexpressed Eqn (4) for Koepf & Schemersau we have the identification: σ+τ =  B; σ=D,  so  τ=B-D. From this a,b,c,d,e can be  gleaned.\n\nThe above, is termed the eigevalue equation (e.g. Goertz and Offner), as it can be reexpressed as\n\nΔ(D(x)⋅ω(x)⋅∇yᵢ(x) = λᵢ⋅ω(x)⋅yᵢ(x)\n\n\n\n\n\n","category":"type"},{"location":"#Implemented-polynomial-types","page":"SpecialPolynomials.jl","title":"Implemented polynomial  types","text":"","category":"section"},{"location":"#Classical-continuous-orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Classical continuous orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical continuous  orthogonal polynomials available:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Legendre\nChebyshev\nChebyshevU\nLaguerre\nHermite\nChebyshevHermite\nGegenbauer\nJacobi\nBessel\nShiftedLegendre","category":"page"},{"location":"#SpecialPolynomials.Legendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Legendre","text":"Legendre{T}\n\nImplements the Legendre polynomials. These have weight function w(x) = 1 over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Legendre([1,2,3])\nLegendre(1⋅P₀(x) + 2⋅P₁(x) + 3⋅P₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(-0.5 + 2.0*x + 4.5*x^2)\n\njulia> p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k\n(Legendre(1.0⋅P₈(x)), Legendre(1.0⋅P₉(x)))\n\njulia> p2m(-1) == 1\nfalse\n\njulia> p2m1(-1) == -1\nfalse\n\njulia> n = 5  # verify  Rodrigues' formula\n5\n\njulia> x = Polynomial(:x)\nPolynomials.Polynomial(1.0*x)\n\njulia> derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)\nPolynomials.Polynomial(0.0)\n\njulia> p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  P₄,P₅\n(Legendre(1.0⋅P₄(x)), Legendre(1.0⋅P₅(x)))\n\njulia> SpecialPolynomials.innerproduct(Legendre, p4,  p5)\n-1.5309832087675112e-16\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Chebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Chebyshev","text":"Chebyshev{<:Number}(coeffs::AbstractVector, var=:x)\n\nChebyshev polynomial of the first kind.\n\nConstruct a polynomial from its coefficients a, lowest order first, optionally in terms of the given variable x. x can be a character, symbol, or string.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> Chebyshev([1, 0, 3, 4])\nChebyshev(1⋅T₀(x) + 3⋅T₂(x) + 4⋅T₃(x))\n\njulia> Chebyshev([1, 2, 3, 0], :s)\nChebyshev(1⋅T₀(s) + 2⋅T₁(s) + 3⋅T₂(s))\n\njulia> one(Chebyshev)\nChebyshev(1.0⋅T₀(x))\n\nnote: Note\nThis is copied from the ChebyshevT example from the Polynomials package by Miles Lucas.\n\nnote: Note\nThe sample chapter available online of Numerical Methods for Special Functions\" by Amparo Gil, Javier Segura, and Nico Temme gives a very nice overview of these polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevU","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevU","text":"ChebyshevU{T}\n\nImplements the Chebyshev polynomials of the second kind. These have weight function w(x) = sqrt(1-x^2) over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = ChebyshevU([1,2,3])\nChebyshevU(1⋅U₀(x) + 2⋅U₁(x) + 3⋅U₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(-2.0 + 4.0*x + 12.0*x^2)\n\njulia> derivative(p)\nChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))\n\njulia> roots(p)\n2-element Vector{ComplexF64}:\n -0.6076252185107651 + 0.0im\n 0.27429188517743175 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Laguerre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Laguerre","text":"Laguerre{α, T <: Number}\n\nThe  Laguerre polynomials have weight function x^α * exp(-x) over the domain [0, oo). The parameter α is specified through the constructor.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{1/2}([1,2,3])\ntypename(Laguerre){0.5}(1⋅Lᵅ₀(x) + 2⋅Lᵅ₁(x) + 3⋅Lᵅ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(9.625 - 9.5*x + 1.5*x^2)\n\nThe Laguerre polynomials are the case α=0.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{0}([1,2,3])\ntypename(Laguerre){0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(6.0 - 8.0*x + 1.5*x^2)\n\njulia> phi(u, i) = derivative(u) -  u # verify Rodrigues' formula for small n; n! L_n = (d/dx-1)^n x^n\nphi (generic function with 1 method)\n\njulia> x = Polynomial(:x)\nPolynomials.Polynomial(1.0*x)\n\njulia> n = 7\n7\n\njulia> factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)\nPolynomials.Polynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*x^2)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hermite","text":"Hermite\n\nThe Hermite polynomials have two versions the physicists (Hermite  or  H) and the probablalists (ChebyshevHermite or  Hₑ). They are  related through  Hᵢ(x) =  2^(i/2) Hₑᵢ(√2 x).\n\nThe Hermite   polynomials have weight  function w(x)=exp(-x^2/2) and domain the real line.\n\nExamples\n\njulia> using Polynomials,  SpecialPolynomials\n\njulia> x = variable(Polynomial{Rational{Int}})\nPolynomials.Polynomial(x)\n\njulia> [basis(Hermite, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Float64, :x}}:\n Polynomials.Polynomial(1.0)\n Polynomials.Polynomial(2.0*x)\n Polynomials.Polynomial(-2.0 + 4.0*x^2)\n Polynomials.Polynomial(-12.0*x + 8.0*x^3)\n Polynomials.Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)\n Polynomials.Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)\n\njulia> [basis(ChebyshevHermite, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Float64, :x}}:\n Polynomials.Polynomial(1.0)\n Polynomials.Polynomial(1.0*x)\n Polynomials.Polynomial(-1.0 + 1.0*x^2)\n Polynomials.Polynomial(-3.0*x + 1.0*x^3)\n Polynomials.Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)\n Polynomials.Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)\n\nnote: Note\nThe Hermite family needs help, as the computed values for Bn,and,Cn are  both 0.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevHermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevHermite","text":"ChebyshevHermite\n\nType for the Probabalist's  Hermite polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Gegenbauer","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Gegenbauer","text":"Gegenbauer{α, T <: Number}\n\nThe Gegenbauer polynomials have weight function (1-x^2)^(α-1/2) over the domain [-1,1]. The parameter α is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  Gegenbauer{1/2}.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Gegenbauer{1/2}([1,2,3])\ntypename(Gegenbauer){0.5}(1⋅Cᵅ₀(x) + 2⋅Cᵅ₁(x) + 3⋅Cᵅ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(-0.5 + 2.0*x + 4.5*x^2)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Jacobi","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Jacobi","text":"Jacobi{α,  β, T}\n\nImplements the Jacobi polynomials. These have weight function w(x) = (1-x)^α ⋅ (1+x)^β over the domain [-1,1]. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Jacobi{-1/2, -1/2}([0,0,1])\ntypename(Jacobi){-0.5,-0.5}(1⋅Jᵅᵝ₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(-0.375 + 0.75*x^2)\n\njulia> monic(p) = (q=convert(Polynomial,p); q/q[end])\nmonic (generic function with 1 method)\n\njulia> monic(p) ≈  monic(basis(Chebyshev, 2))\ntrue\n\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Bessel","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bessel","text":"Bessel{α}\n\nImplements the Bessel polynomials, introduced by Krall and Frink (with b=2). The  case a=2 corresponds to the Bessel polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitray curve in the complex plane enclosing the  origin.  The weight  function is ρ(x)=(2πi)^(-1)∑Γ(α)/Γ(α+n-1)(-β/x)^n,   where β=2.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> 𝐐 = Rational{Int}\nRational{Int64}\n\njulia> x = variable(Polynomial{𝐐})\nPolynomials.Polynomial(x)\n\njulia> [basis(Bessel{3//2, 𝐐}, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Rational{Int64}, :x}}:\n Polynomials.Polynomial(1//1)\n Polynomials.Polynomial(1//1 + 3//4*x)\n Polynomials.Polynomial(1//1 + 5//2*x + 35//16*x^2)\n Polynomials.Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)\n Polynomials.Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)\n Polynomials.Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ShiftedLegendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ShiftedLegendre","text":"ShiftedLegendre\n\nType for the shifted Legendre polynomials: Pˢᵢ(x) =  Pᵢ(2x-1) for x ∈ [0,1].\n\n\n\n\n\n","category":"type"},{"location":"#Classical-discrete-orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Classical discrete orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical discrete  orthogonal polynomials available:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Charlier\nKrawchouk\nMeixner\nHahn\nDiscreteChebyshev\nFallingFactorial","category":"page"},{"location":"#SpecialPolynomials.Charlier","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Charlier","text":"Charlier{μ}\n\nReferences: Koekoek and Swarttouw §1.12\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Krawchouk","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Krawchouk","text":" Krawchouk{p,𝐍}\n\nAlso spelled  Krawtchouk,  Kravhcuk,….\n\nReferences: Koekoek and Swarttouw §1.10;  see  also  Coleman for a different  parameterization.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Meixner","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Meixner","text":"Meixner{γ,μ}\n\nReferences: Koekoek and Swarttouw §1.9\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hahn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hahn","text":"Hahn{α,β,𝐍}\n\nReferences: Koekoek and Swarttouw §1.5\n\nnote: Note\nIn  Koekoek and Swarttouw sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DiscreteChebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DiscreteChebyshev","text":"DiscreteChebyshev\n\nThis uses p22 of Koepf and Schmersau  to define a two-parameter  family of non orthogonal polynomials. See  the example  in DiscreteWeightFunction for implementing  the DiscreteChebyshev  polynomials  from Wikipedia.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> import SpecialPolynomials: Δₓ, ∇ₓ\n\njulia> α,β = 1/2, 1\n(0.5, 1)\n\njulia> P  = DiscreteChebyshev{α,β}\nDiscreteChebyshev{0.5, 1}\n\njulia> i = 5\n5\n\njulia> yᵢ = basis(P, i)\nDiscreteChebyshev(1.0⋅K⁽ᵅᵝ⁾₅(x))\n\njulia> x = variable(P)\nDiscreteChebyshev(- 2.0⋅K⁽ᵅᵝ⁾₀(x) + 2.0⋅K⁽ᵅᵝ⁾₁(x))\n\njulia> a,b,c,d,e = SpecialPolynomials.abcde(P)\n(a = 0, b = 0, c = 1, d = 0.5, e = 1)\n\njulia> λᵢ  = -(a*i*(i-1)  + d*i)\n-2.5\n\njulia> Δₓ(∇ₓ(yᵢ)) +  (α*x + β) * Δₓ(yᵢ) ≈ -λᵢ*yᵢ # p22: \"are not orthogonal, but satisfy the difference equation...\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.FallingFactorial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.FallingFactorial","text":"FallingFactorial{T}\n\nConstruct  a  polynomial with   respect to the basis x⁰̲,  x¹̲, x²̲, … where xⁱ̲ = x  ⋅  (x-1) ⋅  (x-2)  ⋯ (x-i+1) is the falling Pochhammer  symbol.  See Falling factorial  for several  facts about this  polynomial basis.\n\nIn Koepf and Schmersau connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(FallingFactorial, 3)\nFallingFactorial(1.0⋅x³̲)\n\njulia> x = variable(Polynomial)\nPolynomials.Polynomial(1.0*x)\n\njulia> p(x) ≈ x*(x-1)*(x-2)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Some non-exported methods are available or define each of  the classical orthogonal polynomials:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.weight_function\nSpecialPolynomials.generating_function\nSpecialPolynomials.abcde\nSpecialPolynomials.An\nSpecialPolynomials.Bn\nSpecialPolynomials.Cn\nSpecialPolynomials.jacobi_matrix\nSpecialPolynomials.gauss_nodes_weights\nSpecialPolynomials.lagrange_barycentri_nodes_weights","category":"page"},{"location":"#SpecialPolynomials.weight_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.weight_function","text":"weight_function(p)\nweight_function(::Type{P})\n\nFor an orthogonal polynomial type, a function w with ∫ B_n(t) B_m(t) w(t) dt = 0 when n and m are not equal.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.generating_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.generating_function","text":"generating_function(p)\ngenerating_function(::Type{P})\n\nThe generating function is a function defined by: (t,x) -> sum(t^n Pn(x) for n in 0:oo).\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.abcde","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.abcde","text":"abcde\n\nA named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (a⋅x²+b⋅x+c)*P₍ᵢ₊₂₎'' + (d⋅x + e) * P₍ᵢ₊₁₎ + λᵢ Pᵢ = 0.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.An","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.An","text":"An(::Type{P},n)\n\nOrthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:\n\nP_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}\n\nIf the polynomials are monic, this is usually parameterized as:\n\nπ_{n+1} = (x - α̃_n) π_n - β̃_n π_{n-1}\n\nThese functions are used through recursion when evaluating the polynomials, converting to Polynomial format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Bn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bn","text":"Bn(::Type{P},n)\nBn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Cn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Cn","text":"Cn(::Type{P},n)\nCn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.jacobi_matrix","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jacobi_matrix","text":"jacobi_matrix(::Type{P}, n)\n\nThe Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the alphaᵢ values, the off diagonal entries, the square root of the  betaᵢ values. This matrix has the properties that\n\nthe eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.\nthe normalized eigenvectors have initial term proportional to the weights in a quadrature formula\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.gauss_nodes_weights","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.gauss_nodes_weights","text":"gauss_nodes_weights(::Type{P}, n)\n\nReturns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.\n\nWhen loaded, the values are computed through  the FastGaussQuadrature package.\n\nFor some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. \"A fast algorithm for the calculation of the roots of special functions.\" SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used.\n\nFor others the Jacobi matrix, Jn, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of Jn, the weights a scaling of the first component of the normalized eigen vectors (β_0 * [v[1] for v in vs])\n\n\n\n\n\n","category":"function"},{"location":"#Defining-new-types","page":"SpecialPolynomials.jl","title":"Defining new types","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  abcde  method are known.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Polynomial systems  can also be generated  through  an associated weight function.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"WeightFunction\nDiscreteWeightFunction","category":"page"},{"location":"#SpecialPolynomials.WeightFunction","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.WeightFunction","text":"WeightFunction{T}\n\nA type for orthogonal polynomials relative to some weight function. The Wheeler or modified Chebyshev algorithm (Gautschi, Press and Teukolsky) is used to generate the three-term recurrence relation.\n\nIf the second order differential equation, σ⋅p'' + τ⋅p' + λ⋅p=- is known, using that to define the polynomial type would be preferred, as then several additional properties follow for free.\n\nThe key computation is the modified moment, ∫πⱼ dw where πⱼ is the jth basis vector for an associated monic system, P, and w is the weight function.  These values are registered through the @register_weight_function(Type, P, w) macro, as illustrated in the examples.\n\nExample.\n\nToy example with ChebyshevU being derived using the  Chebyshev system.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP = SpecialPolynomials\nSpecialPolynomials\n\njulia> SP.@register0 Toy SP.WeightFunction   # register a  Toy  example\n\njulia> SP.@register_weight_function Toy MonicChebyshev SP.weight_function(ChebyshevU)\n\njulia> [SP.Cn.(Toy, 1:5) SP.Cn.(MonicChebyshevU, 1:5)]\n5×2 Matrix{Float64}:\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n 0.25  0.25\n\nElliptic orthogonal polynomials on  [-1,1]. Demo 2 of Gautschi.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> N,  ω² = 40, 0.999\n(40, 0.999)\n\njulia> w(t) = ((1-ω²*t^2)*(1-t^2))^(-1/2)\nw (generic function with 1 method)\n\njulia> SP.@register0 WF SP.WeightFunction\n\njulia> SP.@register_weight_function WF MonicChebyshev w\n\njulia> αs, βs = -SP.Bn.(WF, 0:5), SP.Cn.(WF, 0:5);\n\njulia> [αs βs]\n6×2 Matrix{Float64}:\n -1.87309e-15  9.68226\n -7.11555e-18  0.793782\n -1.76472e-15  0.119868\n -2.89401e-15  0.22704\n -4.11827e-15  0.241061\n -5.47762e-15  0.245428\n\nThe main computation involved in this is the modified moment, νⱼ = ∫πⱼ dw, computed with QuadGK.quadgk. For some examples, this computation can be completed directly and the modified_moment method may be overloaded for the type. This example is from Press and Teukolsky, where the modified moments are given through the function v(j) defined below.\n\njulia> using Polynomials, SpecialPolynomials, SpecialFunctions\n\njulia> const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> w(t) = -log(t)\nw (generic function with 1 method)\n\njulia> SP.@register0 WF1 SP.WeightFunction   #  register  type WF1 as a weight function\n\njulia> SP.@register_weight_function WF1  MonicShiftedLegendre w\n\njulia> ν(j) = iszero(j) ? 1 : (-1)^j * gamma(j+1)^2 / (j*(j+1)*gamma(2j+1)) # help  out\nν (generic function with 1 method)\n\njulia> SP.modified_moment(::Type{WF1},  j::Int) = ν(j)\n\njulia> αs, βs = -SP.Bn.(WF1, 0:5), SP.Cn.(WF1, 0:5);\n\njulia> [αs βs]\n6×2 Matrix{Float64}:\n -0.75      1.0\n -0.381148  0.423611\n -0.504058  0.172646\n -0.516236  0.203166\n -0.517168  0.222419\n -0.513854  0.239667\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DiscreteWeightFunction","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DiscreteWeightFunction","text":"DiscreteWeightFunction\n\nFor a discrete measure, dλ = ∑ wᵢ δ(x - xᵢ), specified through two vectors, xs and ws, a collection of monic orthogonal polynomials is produced through Darboux's formula for α_n and β_n using the 3-term recurrence defined by π_{n+1} = (x-α_n)⋅π_n - β_n⋅π_{n-1} (An=1, Bn=-α_n, Cn=β_n) and the discrete Stieltjes method Guatschi §3.1.\n\nExample\n\nDiscrete Chebyshev by its weight function (uniform  on 0,1,…,N-1)\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> const SP = SpecialPolynomials;\n\njulia> N = 9\n9\n\njulia> xs, ws = collect(0:N-1), ones(N);   # w(x) = ∑ wⱼ⋅δ(x-xⱼ)\n\njulia> SP.@register0 DWF DiscreteWeightFunction\n\njulia> SP.@register_discrete_weight_function(DWF, xs, ws)\n\njulia> [SP.Bn.(DWF, 0:N-1) SP.Cn.(DWF, 0:N-1)]\n9×2 Matrix{Float64}:\n -4.0  9.0\n -4.0  6.66667\n -4.0  5.13333\n -4.0  4.62857\n -4.0  4.12698\n -4.0  3.53535\n -4.0  2.83217\n -4.0  2.01026\n -4.0  1.06667\n\njulia> i,j = 3,4; ## check  that ∫pᵢpⱼdw  = 0    for i,j=3,4\n\njulia> sum(basis(DWF,i)(x) *  basis(DWF,j)(x) * w for  (x,w) in zip(xs, ws))\n5.684341886080802e-14\n\njulia> ## Gogin, Hirvensalo (https://doi.org/10.1007/s10958-017-3410-8) characterization\n       D(k,N,x) =  sum((-1)^l * binomial(k+l,k) * binomial(N-l,k-l) *  SP.generalized_binomial(x,l) for l in 0:k)\nD (generic function with 1 method)\n\njulia> x = variable()\nPolynomials.Polynomial(x)\n\njulia> ps,qs = [D(k,N-1,x)  for  k in 0:N-1], [basis(DWF, k)(x) for k  in 0:N-1];\n\njulia> all(qs .* [p[end] for p  in ps] .≈ ps)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#Interpolating-polynomials","page":"SpecialPolynomials.jl","title":"Interpolating polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractInterpolatingPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractInterpolatingPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractInterpolatingPolynomial","text":"AbstractInterpolatingPolynomial{T,X}\n\nAbstract type for interpolating polynomials.\n\nThese are polynomial representations of p(x) satisfying p(x_i) = y_i for a specified set of x values and y values.\n\nFor a collection of points (x_0,y_0), ..., (x_n, y_n) there is a unique polynomial of degree n or less satisfying p(x_i)=y_i. This fact allows the specification of p(x) using a vector of coefficients relative to some set of basis vectors.\n\nThe two main types, Lagrange and Newton, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like convert(::Type, p) will not work. Use fit(Type, xs, p), as appropriate, instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Lagrange\nNewton","category":"page"},{"location":"#SpecialPolynomials.Lagrange","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Lagrange","text":"Lagrange(xs, [ws], coeffs, [var])\n\nLagrange interpolation of points (xᵢ, fᵢ) for i ∈ 0..n.\n\nxs, coeffs: the interpolating coordinates.\nws: weights used in the barycentric representation. (From SpecialPolynomials.lagrange_barycentric_weights or SpecialPolynomials.lagrange_barycentric_nodes_weights.)\nvar: the polynomial indeterminate\n\nExtended help\n\nThe Lagrange interpolation of points (xᵢ, fᵢ) for i ∈ 0:n is the polynomial p(x) = ∑ᵢ lⱼ(x) fⱼ.\n\nThe basis vectors lⱼ(x) are 1 on xⱼ and 0 on xᵢ when i ≠ j. That is, lⱼ(x) = Π_{i ≠ j}(x-xᵢ)/Π_{i ≠j}(xⱼ-xᵢ). These can be rewritten in terms of weights, wⱼ, depending on the xᵢ only, yielding lⱼ = l(x) wⱼ/(x - xⱼ) with l(x) = Π(x-xᵢ). Going further, yields the barycentric formula:\n\np(x) = (∑ wⱼ / (x - xⱼ) ⋅ fⱼ) /  (∑ wⱼ / (x - xⱼ) ).\n\nThis representation has several properties, as detailed in Berrut and Trefethen Barycentric Lagrange Interpolation.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1⋅ℓ_0(x) + 2⋅ℓ_1(x) + 3⋅ℓ_2(x))\n\njulia> p.([1,2,3]) # the coefficients\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> convert(Polynomial,  p)\nPolynomials.Polynomial(1.0*x)\n\nThe instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as variable or convert(Lagrange, ...). For the former we can use an instance, for the latter we can use fit:\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1⋅ℓ_0(x) + 2⋅ℓ_1(x) + 3⋅ℓ_2(x))\n\njulia> variable(p)\nLagrange(1⋅ℓ_0(x) + 2⋅ℓ_1(x) + 3⋅ℓ_2(x))\n\njulia> q = Polynomial([0,0,1])\nPolynomials.Polynomial(x^2)\n\njulia> qq = fit(Lagrange, p.xs, p.ws, q)\nLagrange(1⋅ℓ_0(x) + 4⋅ℓ_1(x) + 9⋅ℓ_2(x))\n\njulia> convert(Polynomial, qq)\nPolynomials.Polynomial(1.0*x^2)\n\nFor a given set of nodes, SpecialPolynomials.lagrange_barycentric_weights can compute the weights.  For all but modest values of n, interpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. (They should have asymptotic density of 1/√(1-x^2) over [-1,1].) For P=Chebyshvev and P=ChebyshevU, the function SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n) will return a good choice of n+1 points over [-1,1] along with precomputed weights.\n\njulia> xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(Chebyshev, 64);\n\n\njulia> f(x) = exp(-x)*sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Lagrange, xs, f.(xs));\n\n\njulia> degree(p)\n64\n\njulia> maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) <= 1e-14\ntrue\n\nnote: Note\nThe above example is more directly done through fit(Chebyshev, f, 64), though the resulting polynomial will reference a different basis.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Newton","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Newton","text":"Newton{N,S,T,X}\n\nA Newton interpolating polynomial uses a basis 1, (x-x_0), (x-x_0)(x-x_1), ..., (x-x0)(x-x1)⋅⋅⋅(x-x_{n-1}) and coefficients (in forward form) f[x_0], f[x_0,x_1], ...,f[x_0,...,x_n]. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.\n\nThe easiest way to construct an instance is with fit, as in:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;\n\njulia> p = fit(Newton, xs, f)\nNewton(5.0⋅p_1(x) + 6.0⋅p_2(x) + 1.0⋅p_3(x))\n\njulia> p.(xs) == f.(xs)  # p interpolates\ntrue\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(1.0 - 2.0*x + 1.0*x^3)\n\n\n\n\n\n","category":"type"},{"location":"#Other-polynomials","page":"SpecialPolynomials.jl","title":"Other polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Bernstein","category":"page"},{"location":"#SpecialPolynomials.Bernstein","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bernstein","text":"Bernstein{N, T, X}\n\nA Bernstein  polynomial is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, 𝐍, this is a set of 𝐍+1 degree 𝐍 polynomials of the form: β_{𝐍,ν} =  (ν choose 𝐍) x^ν  (1-x)^{𝐍-ν}, 0 ≤ x ≤ 1.\n\nThe Bernstein{𝐍,T} type represents a polynomial of degree 𝐍 or less with a linear combination of the basis vectors using coefficients of type T.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(Bernstein{3},  2)\nBernstein(1⋅β₂,₂(x))\n\njulia> convert(Polynomial, p)\nPolynomials.Polynomial(1.0*x^2)\n\nnote: Note\nStaticUnivariatePolynomials Offers a  more  performant version.\n\n\n\n\n\n","category":"type"},{"location":"#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-ᴺ-bᵢBᵢ(t)):","page":"SpecialPolynomials.jl","title":"Example of a Bezier curve (parameterized by r(t) = ∑₀ᴺ bᵢBᵢ(t)):","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nbs = [[220, 260], [220, 40], [35, 100],  [120, 140]]\n\np = Bernstein(bs)\nts = range(0, stop=1, length=50)\nps = p.(ts)\nxs, ys = [[pᵢ[1] for pᵢ ∈ ps], [pᵢ[2] for pᵢ ∈ ps]]\np = plot(xs, ys, legend=false)\nscatter!(p, [b[1] for b in bs], [b[2] for b in bs])\n\n#show(current())  # hide\n\nsavefig(\"bezier.svg\")  # hide","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"(Image: )","category":"page"}]
}
