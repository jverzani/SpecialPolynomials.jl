var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"examples/#Construction","page":"Examples","title":"Construction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This package provides several types to represent polynomials relative to bases different from the standard polynomial basis, 1,x,xÂ², xÂ³ etc.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, the Legendre polynomials are a collection of polynomials on [-1,1]. The first few may be seen through:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials\n\njulia> p0 = Legendre([1])\nLegendre(1â‹…Pâ‚€(x))\n\njulia> p1 = Legendre([0,1])\nLegendre(1â‹…Pâ‚(x))\n\njulia> p2 = Legendre([0,0,1])\nLegendre(1â‹…Pâ‚‚(x))\n\njulia> p3 = Legendre([0,0,0,1])\nLegendre(1â‹…Pâ‚ƒ(x))\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A plot recipe is useful for a graphical view:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials  # hide\nn = 6\nÏˆâ‚, Ïˆâ‚‚, Ïˆâ‚ƒ, Ïˆâ‚„, Ïˆâ‚…, Ïˆâ‚† = basis.(Legendre, 0:n - 1)\nkw = (xlabel=\"r\", ylabel=\"Ïˆâ‚™(r)\", legend=false)\nsps = [\n  plot( Ïˆâ‚, label=\"Ïˆâ‚(r)\"; kw...),\n  plot( Ïˆâ‚‚, label=\"Ïˆâ‚‚(r)\"; kw...),\n  plot( Ïˆâ‚ƒ, label=\"Ïˆâ‚ƒ(r)\"; kw...),\n  plot( Ïˆâ‚„, label=\"Ïˆâ‚„(r)\"; kw...),\n  plot( Ïˆâ‚…, label=\"Ïˆâ‚…(r)\"; kw...),\n  plot( Ïˆâ‚†, label=\"Ïˆâ‚†(r)\"; kw...),\n]\np = plot(sps..., layout=(3, 2))\nsavefig(p, \"LegendrePolynomials.svg\"); nothing  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The coefficients, e.g., [0,0,0,1] indicate a polynomial 0â‹…p0 + 0â‹…p1 + 0â‹…p2 + 1â‹…p3. The show method expresses these polynomials relative to their bases. More familiar expressions are seen by conversion to the standard basis. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> convert.(Polynomial, [p0,p1,p2,p3])\n4-element Vector{Polynomial{Float64, :x}}:\n Polynomial(1.0)\n Polynomial(1.0*x)\n Polynomial(-0.5 + 1.5*x^2)\n Polynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Polynomial instances are callable. We have, for example, to evaluate a polynomial at a set of points:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p3.([1/4, 1/2, 3/4])\n3-element Vector{Float64}:\n -0.3359375\n -0.4375\n -0.0703125","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Conversion can also be achieved through polynomial evaluation, using a variable x in the Polynomial basis:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> x = variable(Polynomial)\nPolynomial(1.0*x)\n\njulia> p3(x)\nPolynomial(-1.5*x + 2.5*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Representation in another basis can be achieved this way:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> u = variable(ChebyshevU)\nChebyshevU(0.5â‹…Uâ‚(x))\n\njulia> p3(u)\nChebyshevU(- 0.125â‹…Uâ‚(x) + 0.3125â‹…Uâ‚ƒ(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For most of the orthogonal polynomials, a conversion from the standard basis is provided, and a conversion between different parameter values  for the  same polynomial type are provided. Conversion methods between other polynomial types are not provided, but either evaluation, as above, or conversion through the Polynomial type is possible. For the orthogonal polynomial types, as possible and when loaded, conversion utilizes the FastTransforms package; this package can handle conversion between polynomials with very high degree.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the basis functions, the basis function can be used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> h0,h1,h2,h3 = basis.(Hermite, 0:3);\n\njulia> x = variable();\n\njulia> h3(x)\nPolynomial(-12.0*x + 8.0*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For numeric evaluation of just a basis polynomial of a classical orthogonal polynomial system, the Basis constructor provides a direct evaluation without the construction of an intermediate polynomial:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Basis(Hermite, 3)(0.5)\n-5.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Evaluation with `Basis` is not robust\nThe evaluation of a Basis object relies on a classical hypergeometric representation and for values of n as small as 30 can be very susceptible to round off error.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If the coefficients of a polynomial relative to the polynomial type are known, they can be directly passed to the constructor:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Laguerre{0}([1,2,3])\nLaguerre{0}(1â‹…Lâ‚€(x) + 2â‹…Lâ‚(x) + 3â‹…Lâ‚‚(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some polynomial types are parameterized, as above. The parameters may be passed to the type, as in this example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Jacobi{1/2, -1/2}([1,2,3])\nJacobi{0.5,-0.5}(1â‹…Jáµ…áµâ‚€(x) + 2â‹…Jáµ…áµâ‚(x) + 3â‹…Jáµ…áµâ‚‚(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the background, in this instance, the parameters are passed to the underlying JacobiBasis{Î±, Î²} type.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The polynomial types specified above are orthogonal, meaning the inner product of different basis vectors will be 0. For example:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using QuadGK\n\n\njulia> P = Legendre\nPolynomials.MutableDensePolynomial{SpecialPolynomials.LegendreBasis}\n\njulia> p4,p5 = basis.(P, [4,5])\n2-element Vector{Polynomials.MutableDensePolynomial{SpecialPolynomials.LegendreBasis, Float64, :x}}:\n Legendre(1.0â‹…Pâ‚„(x))\n Legendre(1.0â‹…Pâ‚…(x))\n\njulia> wf, dom = SpecialPolynomials.weight_function(P), Polynomials.domain(P);\n\n\njulia> quadgk(x -> p4(x) * p5(x) *  wf(x), first(dom), last(dom))\n(0.0, 0.0)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The unexported innerproduct will compute this as well, without the need to specify the domain or weight function, which can be gleaned from the type.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SpecialPolynomials.innerproduct(P, p4, p5)\n-1.111881270890998e-16","category":"page"},{"location":"examples/#Polynomial-methods","page":"Examples","title":"Polynomial methods","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For each polynomial type, this package implements as many of the methods for polynomials defined in Polynomials, as possible.","category":"page"},{"location":"examples/#Evaluation","page":"Examples","title":"Evaluation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Evaluation, as seen, is done through making polynomial objects callable:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = Chebyshev\nChebyshev\n\njulia> p = P([1,2,3,4])\nChebyshev(1â‹…Tâ‚€(x) + 2â‹…Tâ‚(x) + 3â‹…Tâ‚‚(x) + 4â‹…Tâ‚ƒ(x))\n\njulia> p(0.4)\n-4.016","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By default, for classical orthogonal polynomials,  the Clenshaw reduction formula is used. For such polynomials, an alternative is to use the hypergeometric formulation. (The evaluation Basis(P,n)(x) uses this.) There is an unexported method to compute through this means:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> SpecialPolynomials.eval_hyper(P, coeffs(p),  0.4)\n-4.016","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(As mentioned before, evaluating the hypergeometric formula for even moderate size n can be numerically unstable.)","category":"page"},{"location":"examples/#Arithmetic","page":"Examples","title":"Arithmetic","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For example, basic arithmetic operations  are defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU\nChebyshevU\n\njulia> p,q = P([1,2,3,4]), P([-2,0,1,2])\n(ChebyshevU(1â‹…U_0(x) + 2â‹…U_1(x) + 3â‹…U_2(x) + 4â‹…U_3(x)), ChebyshevU(- 2â‹…U_0(x) + 1â‹…U_2(x) + 2â‹…U_3(x)))\n\njulia> p + 1\nChebyshevU(2â‹…U_0(x) + 2â‹…U_1(x) + 3â‹…U_2(x) + 4â‹…U_3(x))\n\njulia> -p\nChebyshevU(- 1â‹…U_0(x) - 2â‹…U_1(x) - 3â‹…U_2(x) - 4â‹…U_3(x))\n\njulia> p + q\nChebyshevU(- 1â‹…U_0(x) + 2â‹…U_1(x) + 4â‹…U_2(x) + 6â‹…U_3(x))\n\njulia> p*q\nChebyshevU(9â‹…U_0(x) + 8â‹…U_1(x) + 10â‹…U_2(x) + 6â‹…U_3(x) + 15â‹…U_4(x) + 10â‹…U_5(x) + 8â‹…U_6(x))\n\njulia> p^2\nChebyshevU(30â‹…U_0(x) + 40â‹…U_1(x) + 51â‹…U_2(x) + 44â‹…U_3(x) + 41â‹…U_4(x) + 24â‹…U_5(x) + 16â‹…U_6(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Multiplication formulas may not be defined for each type, and a fall back may be used where the multiplication is done with respect to the standard basis and the answer re-represented:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = Jacobi{1/2, -1/2}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.JacobiBasis{0.5, -0.5}}\n\njulia> p,q = P([1,2]), P([-2,1])\n(Jacobi{0.5,-0.5}(1â‹…Jáµ…áµâ‚€(x) + 2â‹…Jáµ…áµâ‚(x)), Jacobi{0.5,-0.5}(- 2â‹…Jáµ…áµâ‚€(x) + 1â‹…Jáµ…áµâ‚(x)))\n\njulia> p * q\nJacobi{0.5,-0.5}(- 1.5â‹…Jáµ…áµâ‚€(x) - 2.0â‹…Jáµ…áµâ‚(x) + 1.3333333333333333â‹…Jáµ…áµâ‚‚(x))","category":"page"},{"location":"examples/#Derivatives-and-integrals","page":"Examples","title":"Derivatives and integrals","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The classic continuous orthogonal polynomials  have  the derivative  and integrate methods defined:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P = ChebyshevU{Float64}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.ChebyshevUBasis, Float64}\n\njulia> p = P([1,2,3])\nChebyshevU(1.0â‹…Uâ‚€(x) + 2.0â‹…Uâ‚(x) + 3.0â‹…Uâ‚‚(x))\n\njulia> dp = derivative(p)\nChebyshevU(4.0â‹…Uâ‚€(x) + 12.0â‹…Uâ‚(x))\n\njulia> convert.(Polynomial, (p, dp))\n(Polynomial(-2.0 + 4.0*x + 12.0*x^2), Polynomial(4.0 + 24.0*x))\n\njulia> P = Jacobi{1//2, -1//2}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.JacobiBasis{1//2, -1//2}}\n\njulia> p,q = P([1,2]), P([-2,1])\n(Jacobi{1//2,-1//2}(1â‹…Jáµ…áµâ‚€(x) + 2â‹…Jáµ…áµâ‚(x)), Jacobi{1//2,-1//2}(- 2â‹…Jáµ…áµâ‚€(x) + 1â‹…Jáµ…áµâ‚(x)))\n\njulia> p * q # as above, only with rationals for parameters\nJacobi{1//2,-1//2}(- 1.5â‹…Jáµ…áµâ‚€(x) - 2.0â‹…Jáµ…áµâ‚(x) + 1.3333333333333333â‹…Jáµ…áµâ‚‚(x))\n\njulia> P = Jacobi{1//2, 1//2}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.JacobiBasis{1//2, 1//2}}\n\njulia> p = P([1,2,3])\nJacobi{1//2,1//2}(1â‹…Jáµ…áµâ‚€(x) + 2â‹…Jáµ…áµâ‚(x) + 3â‹…Jáµ…áµâ‚‚(x))\n\njulia> dp = derivative(p)\nJacobi{1//2,1//2}(3.0â‹…Jáµ…áµâ‚€(x) + 10.0â‹…Jáµ…áµâ‚(x))\n\njulia> integrate(p)\nJacobi{1//2,1//2}(0.24999999999999994â‹…Jáµ…áµâ‚(x) + 0.6â‹…Jáµ…áµâ‚‚(x) + 0.5714285714285714â‹…Jáµ…áµâ‚ƒ(x))\n\njulia> integrate(p, 0, 1)\n3.125000000000001","category":"page"},{"location":"examples/#Conversion","page":"Examples","title":"Conversion","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Expressing a polynomial in type P in type Q is done through several possible means:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> P,Q = Gegenbauer{1//3}, Gegenbauer{2//3}\n(Polynomials.MutableDensePolynomial{SpecialPolynomials.GegenbauerBasis{1//3}}, Polynomials.MutableDensePolynomial{SpecialPolynomials.GegenbauerBasis{2//3}})\n\njulia> p = P([1,2,3.0])\nGegenbauer{1//3}(1.0â‹…Cáµ…â‚€(x) + 2.0â‹…Cáµ…â‚(x) + 3.0â‹…Cáµ…â‚‚(x))\n\njulia> convert(Q, p)\nGegenbauer{2//3}(0.7999999999999999â‹…Cáµ…â‚€(x) + 1.0â‹…Cáµ…â‚(x) + 1.1999999999999997â‹…Cáµ…â‚‚(x))\n\njulia> p(variable(Q))\nGegenbauer{2//3}(0.7999999999999999â‹…Cáµ…â‚€(x) + 1.0â‹…Cáµ…â‚(x) + 1.1999999999999997â‹…Cáµ…â‚‚(x))\n\njulia> SpecialPolynomials._convert_cop(Q,p)\nGegenbauer{2//3}(0.8â‹…Cáµ…â‚€(x) + 1.0â‹…Cáµ…â‚(x) + 1.2000000000000002â‹…Cáµ…â‚‚(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The first uses a method from the FastTransforms package (when loaded). This package can handle polynomials of very high degree. It is used by default, as much as possible. The second uses polynomial evaluation (Clenshaw evaluation) to perform the conversion. The third uses the structural equations for conversion, when possible, and defaults to converting through the Polynomial type","category":"page"},{"location":"examples/#Roots","page":"Examples","title":"Roots","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The roots function finds the roots of a polynomial","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p = Legendre([1,2,2,1])\nLegendre(1â‹…Pâ‚€(x) + 2â‹…Pâ‚(x) + 2â‹…Pâ‚‚(x) + 1â‹…Pâ‚ƒ(x))\n\njulia> rts = roots(p); rts â‰ˆ [-1, -1/5, 0]\ntrue\n\njulia> maximum(absâˆ˜p, rts) <= 10eps() # small residual\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we see fromroots and roots are related, provided a monic polynomial is used:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using Polynomials, SpecialPolynomials; const SP=SpecialPolynomials\nSpecialPolynomials\n\njulia> P = Jacobi{1/2,-1/2}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.JacobiBasis{0.5, -0.5}}\n\n\njulia> p = P([1,1,2,3])\nJacobi{0.5,-0.5}(1â‹…Jáµ…áµâ‚€(x) + 1â‹…Jáµ…áµâ‚(x) + 2â‹…Jáµ…áµâ‚‚(x) + 3â‹…Jáµ…áµâ‚ƒ(x))\n\njulia> q = SP.monic(p) # monic is not exported\nJacobi{0.5,-0.5}(0.13333333333333333â‹…Jáµ…áµâ‚€(x) + 0.13333333333333333â‹…Jáµ…áµâ‚(x) + 0.26666666666666666â‹…Jáµ…áµâ‚‚(x) + 0.4â‹…Jáµ…áµâ‚ƒ(x))\n\njulia> fromroots(P, roots(q)) - q |> u -> truncate(u, atol=sqrt(eps()))\nJacobi{0.5,-0.5}(0.0 + 0.0im)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For many of the orthogonal polynomials, the roots are found from the comrade matrix using a mathcalO(n^2) algorithm of Aurentz, Vandebril, and Watkins, which computes in a more efficient manner the eigvals(SpecialPolynomials.comrade_matrix(p)). Alternatively, in theory roots may be identified from the companion matrix of the polynomial, once expressed in the standard basis. This approach is the fallback approach for other polynomial types, but is prone to numeric issues.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For orthogonal polynomials, the roots of the basis vectors are important for quadrature. For larger values of n, the eigenvalues of the unexported jacobi_matrix also identify these roots, but the algorithm is more stable than conversion to the standard basis","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> roundâ€²(p) = map(x -> round(x, digits=6), p)\nroundâ€² (generic function with 1 method)\n\njulia> p4 = basis(Legendre, 4)\nLegendre(1.0â‹…Pâ‚„(x))\n\njulia> roots(p4) .|> real .|> roundâ€²\n4-element Vector{Float64}:\n -0.861136\n -0.339981\n  0.339981\n  0.861136\n\njulia> eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 4)) .|> x -> round(x, digits=10)\n4-element Vector{Float64}:\n -0.8611363116\n -0.3399810436\n  0.3399810436\n  0.8611363116","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"At higher degrees, the difference in  stability comes out. For the special case of a basis polynomial, we see this difference in the maximum residual:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> using LinearAlgebra\n\njulia> p50 = basis(Legendre{Float64}, 50)\nLegendre(1.0â‹…Pâ‚…â‚€(x))\n\njulia> as = eigvals(Polynomials.companion(p50));\n\njulia> maximum(abs âˆ˜ p50, as) < sqrt(eps())\nfalse\n\njulia> bs = eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 50 ));\n\njulia> maximum(abs âˆ˜ p50, bs) < sqrt(eps())\ntrue\n\njulia> maximum(abs, roots(p50) - bs) < sqrt(eps())\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(The roots of the classic orthogonal polynomials  are  all  real  and distinct.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The unexported gauss_nodes_weights function returns the nodes and weights. For many types (e.g., Jacobi, Legendre, Hermite, Laguerre). As possible, it uses the methods from the FastGaussQuadratures package, which provides O(n) algorithms, where the Jacobi matrix is O(nÂ²).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ws = SpecialPolynomials.gauss_nodes_weights(Legendre, 4)\n([-0.86113631159405, -0.33998104358485537, 0.33998104358485715, 0.8611363115940526], [0.34785484513745607, 0.6521451548625448, 0.652145154862546, 0.3478548451374536])\n\njulia> basis(Legendre, 4).(xs)\n4-element Vector{Float64}:\n -1.199040866595169e-14\n  1.6930901125533637e-15\n -1.6653345369377348e-15\n  1.1102230246251565e-16\n\njulia> f(x) = x^7 - x^6; F(x) = x^8/8 - x^7/7;\n\njulia> sum(f(x)*w for (x,w) in zip(xs, ws)) - (F(1) - F(-1))\n3.3306690738754696e-15","category":"page"},{"location":"examples/#Fitting","page":"Examples","title":"Fitting","text":"","category":"section"},{"location":"examples/#Interpolation","page":"Examples","title":"Interpolation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"For any set of points (x0,y0), (x1,y1), ..., (xn, yn) with unique x values,  there is a unique polynomial of degree n or less that interpolates these points, that is  p(x_i) = y_i. The  fit function will perform polynomial interpolation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ys = [0, 1/4,  1/2,  3/4], [1,2,2,3]\n([0.0, 0.25, 0.5, 0.75], [1, 2, 2, 3])\n\njulia> p1 = fit(Polynomial,  xs, ys) |> roundâ€²\nPolynomial(1.0 + 8.666667*x - 24.0*x^2 + 21.333333*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Lagrange and Newton types represent the polynomial in convenient bases based on the nodes (xs):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p2 = fit(Lagrange, xs, ys)\nLagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 2â‹…â„“_2(x) + 3â‹…â„“_3(x))\n\njulia> p3 = fit(Newton, xs, ys)\nNewton(1.0â‹…p_0(x) + 4.0â‹…p_1(x) - 8.0â‹…p_2(x) + 21.333333333333332â‹…p_3(x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"These all represent the same interpolating polynomial:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> [p1.(xs)-ys  p2.(xs)-ys p3.(xs)-ys]\n4Ã—3 Matrix{Float64}:\n 0.0         0.0  0.0\n 7.8125e-8   0.0  0.0\n 1.25e-7     0.0  0.0\n 1.09375e-7  0.0  0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The Lagrange and Newton  methods allow a function to be specified  in place  of a set of y values:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p = fit(Newton, [1,2,3], x->x^2)\nNewton(1.0â‹…p_0(x) + 3.0â‹…p_1(x) + 1.0â‹…p_2(x))\n\njulia> convert(Polynomial, p)\nPolynomial(1.0*x^2)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Polynomial interpolation can demonstrate the Runge phenomenon if the nodes are evenly spaced and n is large enough. For higher degree fitting, the choice of nodes can greatly effect the approximation of the interpolating polynomial to the function generating the y values. The SpecialPolynomials.lagrange_barycentric_nodes_weights function returns nodes (and accompanying weights) for different polynomial types.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For an orthogonal polynomial type, the zeros of the basis polynomial p_{n+1}, labeled x_0, x_1, ..., x_n are often used as nodes, especially for the Chebyshev nodes (of the first kind).  Gil, Segura, and Temme say \"Interpolation with Chebyshev nodes is not as good as the best approximation ..., but usually it is the best practical possibility for interpolation and certainly much better than equispaced interpolation\"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, the default for fit for degree n will use the zeros of P_{n+1} to interpolate.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can see that some interpolation points lead to better fits than others, in the following graphic:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nf(x) = exp(-x)*sinpi(x)\nplot(f, -1, 1, legend=false, color=:black, linewidth=3)\np=fit(Val(:interpolating), Chebyshev, f, 3); plot!(p, color=:blue)\np=fit(Val(:interpolating), ChebyshevU, f, 3); plot!(p, color=:red)\nfit(Val(:interpolating), Legendre, f, 3); plot!(p, color=:green)\nxs = [-0.5, 0.0, 0.5]\np=fit(Newton, xs, f);\nts = range(-1, 1, length=100); plot!(ts, p.(ts), color=:brown)\nsavefig(\"fitting.svg\"); nothing  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Polynomial-approximation","page":"Examples","title":"Polynomial approximation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are other criteria for fitting that can be used.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If there are a lot of points, it is common to fit with a lower degree polynomial. This won't be an interpolating polynomial, in general. The criteria used to select the polynomial is typically least squares (weighted least squares is also available). Fitting in the standard basis, a degree is specified, as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> xs, ys =  [1,2,3,4], [2.0,3,1,4]\n([1, 2, 3, 4], [2.0, 3.0, 1.0, 4.0])\n\njulia> p1 =  fit(Polynomial, xs,  ys, 1) |> roundâ€² # degree 1  or less\nPolynomial(1.5 + 0.4*x)\n\njulia> p1 =  fit(Polynomial, xs,  ys, 2) |> roundâ€² # degree 2 or less\nPolynomial(4.0 - 2.1*x + 0.5*x^2)\n\njulia> p1 =  fit(Polynomial, xs,  ys) |> roundâ€²    # degree 3 or less (length(xs) - 1)\nPolynomial(-10.0 + 20.166667*x - 9.5*x^2 + 1.333333*x^3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the orthogonal polynomial types, fitting a polynomial to a function using least squares can be solved using the polynomial a0â‹…p0 + a1â‹…p1 + â‹…â‹…â‹… + anâ‹…pn where ai=âˆ«fâ‹…piâ‹…wâ‹…dx / âˆ«pi^2â‹…wâ‹…dx. There is no need to specify values for x:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f(x) = exp(-x) * sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This wavy example is from Trefethen:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f(x) = sin(6x) + sin(60*exp(x))\nf (generic function with 1 method)\n\njulia> p50 = fit(Val(:lsq), Chebyshev{Float64}, f, 50);\n\njulia> maximum(norm(p50(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps()) # cf. graph below\nfalse","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(With 50 points, the approximation misses badly over [-1,1]. There are 45 local extrema on  this interval.)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"However, with more points we have a good fit:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> p196 = fit(Chebyshev{Float64}, f, 196);\n\njulia> maximum(norm(p196(x)-f(x) for x in range(-1,1,length=500))) <= sqrt(eps())  # â‰ˆ 1e-13\ntrue","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nf(x) = sin(6x) + sin(60*exp(x))\np50 = fit(Chebyshev{Float64}, f, 50);\np196 = fit(Chebyshev{Float64}, f, 196);\nplot(f, -1, 1, legend=false, color=:black)\nxs = range(-1, stop=1, length=500) # more points than recipe\nplot!(xs, p50.(xs), color=:blue)\nplot!(xs, p196.(xs), color=:red)\nshow(current())  # hide\nsavefig(\"wavy.svg\"); nothing  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For the  Chebyshev type, the  Val(:series) argument will fit a heuristically identify truncated series  to the function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Polynomials, SpecialPolynomials\nf(x) = sin(6x) + sin(60*exp(x))\np = fit(Val(:series), Chebyshev, f);\ndegree(p)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"note: Note\nThe ApproxFun package provides a framework to quickly and accuratately approximate functions using certain polynomial types. The choice of order and methods for most of Julia's built-in functions are conveniently provided.","category":"page"},{"location":"examples/#Plotting","page":"Examples","title":"Plotting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The plot recipe from the Polynomials package works as expected for the polynomial types in this package. The domain to be plotted over matches that given by Polynomials.domain, unless this is infinite.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A plot of the first few Chebyshev Polynomials of the second kind can be produced as follows:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots, Polynomials, SpecialPolynomials  # hide\n# U1, U2, U3, and U4:\nchebs  = basis.(ChebyshevU, 1:4)\ncolors = [\"#4063D8\", \"#389826\", \"#CB3C33\", \"#9558B2\"]\np = plot(legend=false)\nfor (cheb, col) in zip(chebs, colors)\n  plot!(p, cheb, c=col, lw=5)\nend\nsavefig(p, \"chebs.svg\"); nothing  # hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"#SpecialPolynomials.jl","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Documentation for SpecialPolynomials.jl.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"CurrentModule = SpecialPolynomials","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"DocTestSetup = quote\n  using Polynomials, SpecialPolynomials\nend","category":"page"},{"location":"#Overview","page":"SpecialPolynomials.jl","title":"Overview","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"This package provides a number of different polynomial types to represent polynomials, extending the Polynomials package.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractSpecialPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractSpecialPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractSpecialPolynomial","text":"AbstractSpecialPolynomial{B,T,X}\n\nAn abstract type to distinguish the different polynomial types in this package.\n\nThe concrete types specify different bases for the space of polynomials of degree n or less.\n\nThis package includes:\n\nSeveral classical orthogonal polynomials.\nNewton and Lagrange interpolating polynomials\nBernstein polynomials\n\nAs many of the methods for the base Polynomials class are directly coded if possible, but quite a few depend on conversion to the base Polynomial type (which uses the standard polynomial basis).\n\n\n\n\n\n","category":"type"},{"location":"#Orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractOrthogonalPolynomial\nSpecialPolynomials.AbstractCCOPBasis\nSpecialPolynomials.AbstractCDOPBasis","category":"page"},{"location":"#SpecialPolynomials.AbstractOrthogonalPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractOrthogonalPolynomial","text":"AbstractOrthogonalPolynomial{T,X}\n\nThis is an alias for polynomials with an orthogonal basis (AbstractOrthogonalBasis) specified.\n\nThese polynomials have  several properties, including an accompanying inner product satisfying  âŸ¨yáµ¢, yâ±¼âŸ© = cáµ¢Î´áµ¢â±¼.\n\nIn addition to methods inherited from the underlying AbstractPolynomial  type, orthogonal polynomial  types may have methods   weight_function, generating_function, leading_term, norm2, jacobi_matrix, and gauss_nodes_weights,  though none are  exported.\n\nSubtypes of AbstractCOPBasis <: AbstractOrthogonalBasis utilize the fact that the basis  polynomials  satisfy\n\n(axÂ² + bx + c)yáµ¢''(x) + (dx+e)yáµ¢'(x) + Î»áµ¢yáµ¢(x) = 0 (or a discrete analogue)\n\nwhere the structural relations are functions of a,b,c,d,e. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the Polynomial type (the FallingFactorial type in the discrete  c case),\n\nA key structural relation is the three-term recursion,  yáµ¢â‚Šâ‚ =  (Aáµ¢x +  Báµ¢)yáµ¢ -  Cáµ¢yáµ¢â‚‹â‚. For systems  specified by  a  weight function, the  values of Aáµ¢, Báµ¢, and Cáµ¢ can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the Polynomial  type through evaluation.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCCOPBasis","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCCOPBasis","text":"AbstractCCOPBasis <:  AbstractCOPBasis\n\nFollowing Koepf and Schmersau, a family y(x)=p_n(x)=k_xâ‹…x^n +  ... for  n  âˆˆ  {0, 1,â€¦}, k_n â‰  0 of polynomials is a family of classical continuous orthogonal polynomials if each is  a solution of the differential equation\n\n(aâ‹…xÂ²+bâ‹…x+c) â‹… yáµ¢'' + (dâ‹…x + e) â‹… yáµ¢' + Î»áµ¢â‹… yáµ¢ = 0.\n\nA family is characterized, up to choice of leading term, by the 5 coefficients: a,b,c,d,e. Let Ïƒ = (aâ‹…xÂ²+bâ‹…x+c), Ï„ = (dâ‹…x + e).\n\nFrom these  5  coefficients several structural  equations are represented. For example the three-point recursion.\n\nPâ‚áµ¢â‚Šâ‚â‚Ž = (Aáµ¢â‹…x + Báµ¢) * Páµ¢ - Cáµ¢ *  Pâ‚áµ¢â‚‹â‚â‚Ž,\n\nwhere Aáµ¢,Báµ¢,Cáµ¢ can be represented in formulas involving just  a,b,c,d,e and i.\n\nRearranging   gives the structural equation:\n\nxâ‹…p_n   = [an, bn, cn] â‹… [p_{n+1}, p_n, p_{n-1}]  (Eqn (7))\n\nThe other structural equations are (equation  references are from Koepf and Schmersau):\n\nÏƒâ‹…p'_n  = [Î±n, Î²n, Î³n] â‹…  [p_{n+1}, p_n, p_{n-1}] (Eqn (9), n â‰¥ 1)\n\np_n = [aÌ‚n, bÌ‚n, cÌ‚n]  â‹…  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn (19))\n\nxâ‹…p'_n  = [Î±á´µn, Î²á´µn, Î³á´µn] â‹…  [p'_{n+1}, p'_n, p'_{n-1}] (Eqn  (14))\n\nUsing (7), Clenshaw polynomial evaluation using the three  point recursion is defined.\n\nUsing (19), expressions for derivatives are found.\n\nUsing  (19), expressions for integration are found (p7).\n\nUsing their theorems 2,4, and 5, connection coefficients, C(n,m) satisfying P_n(x) =  âˆ‘  C(n,m)  Q_m(x) (n â‰¥ 0, 0 â‰¤  m â‰¤ n) are  found. These allow  fallback  definitions for convert(Polynomial,p),  convert(P, p::Polynomial), convert(P{Î±â€¦}, p::P(Î²â€¦)) and through composition polynomial  multiplication,  p*q.\n\nIf non-monic versions are desired, then the  leading  term can be  specified through kn() (which by default is defined by the  method k1k0(P,i), the ratio of  káµ¢â‚Šâ‚/káµ¢).  The @register_monic macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the @register_shifted macro is useful  to provide shifted versions (cf. ShiftedLegendre).\n\nRegistering a system, defining an abcde method, and optionally defining k1k0 is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.\n\nThe defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. Chebyshev,ChebyshevU, Hermite, Laguerre), but not all.\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.AbstractCDOPBasis","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractCDOPBasis","text":" AbstractCDOPBasis{T,X} <: AbstractCOPBasis{T,X}\n\nFollowing Koepf  and Schmersau, a family y(x)=p_n(x)=k_xâ‹…x^n +  ... for  n  âˆˆ  {0, 1,â€¦}, k_n â‰  0 of polynomials is a family of classic discrete orthogonal polynomials if it  is  a solution of a differential equation\n\n(aâ‹…xÂ²+bâ‹…x+c) â‹… Î”âˆ‡y + (dâ‹…x + e) â‹… âˆ‡' + Î»áµ¢â‹… y = 0,\n\nwhere  Î”y(x) = y(x+1) - y(x) and âˆ‡y(x) = y(x) - y(x-1).\n\nA family is characterized by the 5 coefficients: a,b,c,d,e. Let Ïƒ = (aâ‹…xÂ²+bâ‹…x+c), Ï„ = (dâ‹…x + e).\n\nAs in the classical-continuous-orthogonal-polynomial case AbstractCCOPBasis, from these 5 values the coefficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.\n\nKoekoek and Swarttouw present an encyclopedia of formula characterizing families of orthogonal polynomials.\n\nFor example, on p29 they give  formulas for Hahn polynomials through:\n\nn(n+Î±+Î²+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1),  with  explicit values  for  B and D. Reexpressing gives: BÎ”y(x) - Dâˆ‡y(x) -Î» y(x)  = 0. From the rexpressed Eqn (4) for Koepf & Schemersau we have the identification: Ïƒ+Ï„ =  B; Ïƒ=D,  so  Ï„=B-D. From this a,b,c,d,e can be  gleaned.\n\nThe above, is termed the eigenvalue equation (e.g. Goertz and Offner), as it can be reexpressed as\n\nÎ”(D(x)â‹…Ï‰(x)â‹…âˆ‡yáµ¢(x) = Î»áµ¢â‹…Ï‰(x)â‹…yáµ¢(x)\n\n\n\n\n\n","category":"type"},{"location":"#Implemented-polynomial-types","page":"SpecialPolynomials.jl","title":"Implemented polynomial  types","text":"","category":"section"},{"location":"#Classical-continuous-orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Classical continuous orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical continuous  orthogonal polynomials available:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Jacobi\nGegenbauer\nChebyshev\nChebyshevU\nLegendre\nShiftedJacobi\nShiftedLegendre\nLaguerre\nHermite\nChebyshevHermite\nBessel","category":"page"},{"location":"#SpecialPolynomials.Jacobi","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Jacobi","text":"Jacobi{Î±,  Î², T}\n\nImplements the Jacobi polynomials. These have weight function w(x) = (1-x)^Î± â‹… (1+x)^Î² over the domain [-1,1]. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Jacobi{-1/2, -1/2}([0,0,1])\nJacobi{-0.5,-0.5}(1â‹…Jáµ…áµâ‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.375 + 0.75*x^2)\n\njulia> monic(p) = (q=convert(Polynomial,p); q/q[end])\nmonic (generic function with 1 method)\n\njulia> monic(p) â‰ˆ  monic(basis(Chebyshev, 2))\ntrue\n\n\nSpecial cases include Jacobi{Î±-1/2,Î±-1/2} = Gegenbauer{Î±}, Jacobi{-1/2,-1/2} = Chebyshev, Jacobi{1/2,1/2} = ChebyshevU, and Jacobi{0,0} = Legendre.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Gegenbauer","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Gegenbauer","text":"Gegenbauer{Î±, T <: Number}\n\nThe Gegenbauer polynomials have weight function (1-x^2)^(Î±-1/2) over the domain [-1,1]. The parameter Î± is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  Gegenbauer{1/2}.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Gegenbauer{1/2}([1,2,3])\nGegenbauer{0.5}(1â‹…Cáµ…â‚€(x) + 2â‹…Cáµ…â‚(x) + 3â‹…Cáµ…â‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.5 + 2.0*x + 4.5*x^2)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Chebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Chebyshev","text":"Chebyshev{<:Number}(coeffs::AbstractVector, var=:x)\n\nChebyshev polynomial of the first kind. These have domain (-11) and weight function 1sqrt1-x^2.\n\nA polynomial is constructed from its coefficients a, lowest order first, optionally in terms of the given variable x. x can be a character, symbol, or string.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> Chebyshev([1, 0, 3, 4])\nChebyshev(1â‹…Tâ‚€(x) + 3â‹…Tâ‚‚(x) + 4â‹…Tâ‚ƒ(x))\n\njulia> Chebyshev([1, 2, 3, 0], :s)\nChebyshev(1â‹…Tâ‚€(s) + 2â‹…Tâ‚(s) + 3â‹…Tâ‚‚(s))\n\njulia> one(Chebyshev)\nChebyshev(1.0â‹…Tâ‚€(x))\n\nnote: Note\nThis is copied from the ChebyshevT example from the Polynomials package by Miles Lucas.\n\nnote: Note\nThe sample chapter available online of Numerical Methods for Special Functions\" by Amparo Gil, Javier Segura, and Nico Temme gives a very nice overview of these polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevU","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevU","text":"ChebyshevU{T}\n\nImplements the Chebyshev polynomials of the second kind. These have weight function w(x) = sqrt(1-x^2) over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = ChebyshevU([1,2,3])\nChebyshevU(1â‹…Uâ‚€(x) + 2â‹…Uâ‚(x) + 3â‹…Uâ‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-2.0 + 4.0*x + 12.0*x^2)\n\njulia> derivative(p)\nChebyshevU(4.0â‹…Uâ‚€(x) + 12.0â‹…Uâ‚(x))\n\njulia> roots(p)\n2-element Vector{ComplexF64}:\n -0.6076252185107651 + 0.0im\n 0.27429188517743175 + 0.0im\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Legendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Legendre","text":"Legendre{T}\n\nImplements the Legendre polynomials. These have weight function w(x) = 1 over the domain [-1,1].\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Legendre([1,2,3])\nLegendre(1â‹…Pâ‚€(x) + 2â‹…Pâ‚(x) + 3â‹…Pâ‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(-0.5 + 2.0*x + 4.5*x^2)\n\njulia> p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k\n(Legendre(1.0â‹…Pâ‚ˆ(x)), Legendre(1.0â‹…Pâ‚‰(x)))\n\njulia> p2m(-1) == 1\nfalse\n\njulia> p2m1(-1) == -1\nfalse\n\njulia> n = 5  # verify  Rodrigues' formula\n5\n\njulia> x = Polynomial(:x)\nPolynomial(1.0*x)\n\njulia> derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)\nLaurentPolynomial(0.0)\n\njulia> p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  Pâ‚„,Pâ‚…\n(Legendre(1.0â‹…Pâ‚„(x)), Legendre(1.0â‹…Pâ‚…(x)))\n\njulia> SpecialPolynomials.innerproduct(Legendre, p4,  p5)\n-1.111881270890998e-16\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ShiftedJacobi","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ShiftedJacobi","text":"ShiftedJacobi\n\nShifted Jacobi polynomial constructor. PÌƒ(x) = P(2x-1). Shifted Jacobi polynomials are orthogonal on 01.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ShiftedLegendre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ShiftedLegendre","text":"ShiftedLegendre\n\nShifted Legendre polynomial constructor. Shifted Legendre polynoials are orthogonal on 01.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Laguerre","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Laguerre","text":"Laguerre{Î±, T <: Number}\n\nThe  Laguerre polynomials have weight function x^Î± * exp(-x) over the domain [0, oo). The parameter Î± is specified through the constructor.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{1/2}([1,2,3])\nLaguerre{0.5}(1â‹…Láµ…â‚€(x) + 2â‹…Láµ…â‚(x) + 3â‹…Láµ…â‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(9.625 - 9.5*x + 1.5*x^2)\n\nThe Laguerre polynomials are the case Î±=0.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = Laguerre{0}([1,2,3])\nLaguerre{0}(1â‹…Lâ‚€(x) + 2â‹…Lâ‚(x) + 3â‹…Lâ‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(6.0 - 8.0*x + 1.5*x^2)\n\njulia> phi(u, i) = derivative(u) -  u # verify Rodrigues' formula for small n; n! L_n = (d/dx-1)^n x^n\nphi (generic function with 1 method)\n\njulia> x = Polynomial(:x)\nPolynomial(1.0*x)\n\njulia> n = 7\n7\n\njulia> factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)\nLaurentPolynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*xÂ²)\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hermite","text":"Hermite\n\nThe Hermite polynomials have two versions the physicists (Hermite  or  H) and the probablalists (ChebyshevHermite or  Hâ‚‘). They are  related through  Háµ¢(x) =  2^(i/2) Hâ‚‘áµ¢(âˆš2 x).\n\nThe Hermite   polynomials have weight  function w(x)=exp(-x^2/2) and domain the real line.\n\nExamples\n\njulia> using Polynomials,  SpecialPolynomials\n\njulia> x = variable(Polynomial{Rational{Int}})\nPolynomial(x)\n\njulia> [basis(Hermite, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Float64, :x}}:\n Polynomial(1.0)\n Polynomial(2.0*x)\n Polynomial(-2.0 + 4.0*x^2)\n Polynomial(-12.0*x + 8.0*x^3)\n Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)\n Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)\n\njulia> [basis(ChebyshevHermite, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Float64, :x}}:\n Polynomial(1.0)\n Polynomial(1.0*x)\n Polynomial(-1.0 + 1.0*x^2)\n Polynomial(-3.0*x + 1.0*x^3)\n Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)\n Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)\n\nnote: Note\nThe Hermite family needs help, as the computed values for Bn,and,Cn are  both 0.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.ChebyshevHermite","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.ChebyshevHermite","text":"ChebyshevHermite\n\nType for the Probabalist's  Hermite polynomials.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Bessel","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bessel","text":"Bessel{Î±}\n\nImplements the Bessel polynomials, introduced by Krall and Frink (with b=2). The  case a=2 corresponds to the Bessel polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitrary curve in the complex plane enclosing the  origin.  The weight  function is Ï(x)=(2Ï€i)^(-1)âˆ‘Î“(Î±)/Î“(Î±+n-1)(-Î²/x)^n,   where Î²=2.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> ð = Rational{Int}\nRational{Int64}\n\njulia> x = variable(Polynomial{ð})\nPolynomial(x)\n\njulia> [basis(Bessel{3//2, ð}, i)(x) for i in 0:5]\n6-element Vector{Polynomial{Rational{Int64}, :x}}:\n Polynomial(1//1)\n Polynomial(1//1 + 3//4*x)\n Polynomial(1//1 + 5//2*x + 35//16*x^2)\n Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)\n Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)\n Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)\n\n\n\n\n\n","category":"type"},{"location":"#Classical-discrete-orthogonal-polynomials","page":"SpecialPolynomials.jl","title":"Classical discrete orthogonal polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"There are  several classical discrete  orthogonal polynomials available:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Charlier\nKrawchouk\nMeixner\nHahn\nDiscreteChebyshev\nFallingFactorial","category":"page"},{"location":"#SpecialPolynomials.Charlier","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Charlier","text":"Charlier{Î¼}\n\nReferences: Koekoek and Swarttouw Â§1.12\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Krawchouk","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Krawchouk","text":" Krawchouk{p,ð}\n\nAlso spelled  Krawtchouk,  Kravhcuk,â€¦.\n\nReferences: Koekoek and Swarttouw Â§1.10;  see  also  Coleman for a different  parameterization.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Meixner","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Meixner","text":"Meixner{Î³,Î¼}\n\nReferences: Koekoek and Swarttouw Â§1.9\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Hahn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Hahn","text":"Hahn{Î±,Î²,ð}\n\nReferences: Koekoek and Swarttouw Â§1.5\n\nnote: Note\nIn  Koekoek and Swarttouw sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DiscreteChebyshev","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DiscreteChebyshev","text":"DiscreteChebyshev\n\nThis uses p22 of Koepf and Schmersau  to define a two-parameter  family of non orthogonal polynomials.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> import SpecialPolynomials: Î”â‚“, âˆ‡â‚“\n\njulia> Î±,Î² = 1/2, 1\n(0.5, 1)\n\njulia> P  = DiscreteChebyshev{Î±,Î²}\nPolynomials.MutableDensePolynomial{SpecialPolynomials.DiscreteChebyshevBasis{0.5, 1}}\n\njulia> i = 5\n5\n\njulia> yáµ¢ = basis(P, i)\nDiscreteChebyshev{0.5,1}(1.0â‹…Kâ½áµ…áµâ¾â‚…(x))\n\njulia> x = variable(P)\nDiscreteChebyshev{0.5,1}(- 2.0â‹…Kâ½áµ…áµâ¾â‚€(x) + 2.0â‹…Kâ½áµ…áµâ¾â‚(x))\n\njulia> a,b,c,d,e = SpecialPolynomials.abcde(P)\n(a = 0, b = 0, c = 1, d = 0.5, e = 1)\n\njulia> Î»áµ¢  = -(a*i*(i-1)  + d*i)\n-2.5\n\njulia> Î”â‚“(âˆ‡â‚“(yáµ¢)) +  (Î±*x + Î²) * Î”â‚“(yáµ¢) â‰ˆ -Î»áµ¢*yáµ¢ # p22: \"are not orthogonal, but satisfy the difference equation...\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.FallingFactorial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.FallingFactorial","text":"FallingFactorial{T}\n\nConstruct  a  polynomial with   respect to the basis xâ°Ì²,  xÂ¹Ì², xÂ²Ì², â€¦ where xâ±Ì² = x  â‹…  (x-1) â‹…  (x-2)  â‹¯ (x-i+1) is the falling Pochhammer  symbol.  See Falling factorial  for several  facts about this  polynomial basis.\n\nIn Koepf and Schmersau connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(FallingFactorial, 3)\nPolynomials.MutableDensePolynomial(1.0â‹…xÂ³Ì²)\n\njulia> x = variable(Polynomial)\nPolynomial(1.0*x)\n\njulia> p(x) â‰ˆ x*(x-1)*(x-2)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Some non-exported methods are available or define each of  the classical orthogonal polynomials:","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.weight_function\nSpecialPolynomials.generating_function\nSpecialPolynomials.abcde\nSpecialPolynomials.An\nSpecialPolynomials.Bn\nSpecialPolynomials.Cn\nSpecialPolynomials.jacobi_matrix\nSpecialPolynomials.gauss_nodes_weights\nSpecialPolynomials.lagrange_barycentric_nodes_weights","category":"page"},{"location":"#SpecialPolynomials.weight_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.weight_function","text":"weight_function(p)\nweight_function(::Type{P})\n\nFor an orthogonal polynomial type, a function w with âˆ« B_n(t) B_m(t) w(t) dt = 0 when n and m are not equal.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.generating_function","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.generating_function","text":"generating_function(p)\ngenerating_function(::Type{P})\n\nThe generating function is a function defined by: (t,x) -> sum(t^n Pn(x) for n in 0:oo).\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.abcde","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.abcde","text":"abcde\n\nA named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (aâ‹…xÂ²+bâ‹…x+c)*Pâ‚áµ¢â‚Šâ‚‚â‚Ž'' + (dâ‹…x + e) * Pâ‚áµ¢â‚Šâ‚â‚Ž + Î»áµ¢ Páµ¢ = 0.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.An","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.An","text":"An(::Type{P},n)\n\nOrthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:\n\nP_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}\n\nIf the polynomials are monic, this is usually parameterized as:\n\nÏ€_{n+1} = (x - Î±Ìƒ_n) Ï€_n - Î²Ìƒ_n Ï€_{n-1}\n\nThese functions are used through recursion when evaluating the polynomials, converting to Polynomial format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Bn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bn","text":"Bn(::Type{B},n)\nBn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.Cn","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Cn","text":"Cn(::Type{B},n)\nCn(p::P, n)\n\ncf. An()\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.jacobi_matrix","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jacobi_matrix","text":"jacobi_matrix(::Type{P}, n)\n\nThe Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the alphaáµ¢ values, the off diagonal entries, the square root of the  betaáµ¢ values. This matrix has the properties that\n\nthe eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.\nthe normalized eigenvectors have initial term proportional to the weights in a quadrature formula\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.gauss_nodes_weights","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.gauss_nodes_weights","text":"gauss_nodes_weights(::Type{P}, n)\n\nReturns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.\n\nWhen loaded, the values are computed through  the FastGaussQuadrature package.\n\nFor some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. \"A fast algorithm for the calculation of the roots of special functions.\" SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used.\n\nFor others the Jacobi matrix, Jn, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of Jn, the weights a scaling of the first component of the normalized eigen vectors (Î²_0 * [v[1] for v in vs])\n\n\n\n\n\n","category":"function"},{"location":"#SpecialPolynomials.lagrange_barycentric_nodes_weights","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.lagrange_barycentric_nodes_weights","text":"lagrange_barycentric_nodes_weights(::Type{<:SpecialPolynomial}, n::Int)\n\nReturn a collection of n+1 nodes and simplified weights the given family of polynomials. There are explicit formula for Chebyshev and Chebyshev, for other classical continuous orthogonal polynomials there is a relationship between the Gauss nodes and weights and the barycentric ones that is used.\n\n\n\n\n\n","category":"function"},{"location":"#Defining-new-types","page":"SpecialPolynomials.jl","title":"Defining new types","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  abcde  method are known.","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Polynomial systems  can also be generated  through  an associated weight function, but the code base currently needs some tending, so this feature is not enabled.","category":"page"},{"location":"#Interpolating-polynomials","page":"SpecialPolynomials.jl","title":"Interpolating polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"SpecialPolynomials.AbstractInterpolatingPolynomial","category":"page"},{"location":"#SpecialPolynomials.AbstractInterpolatingPolynomial","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.AbstractInterpolatingPolynomial","text":"AbstractInterpolatingPolynomial{T,X}\n\nAbstract type for interpolating polynomials.\n\nThese are polynomial representations of p(x) satisfying p(x_i) = y_i for a specified set of x values and y values.\n\nFor a collection of points (x_0,y_0), ..., (x_n, y_n) there is a unique polynomial of degree n or less satisfying p(x_i)=y_i. This fact allows the specification of p(x) using a vector of coefficients relative to some set of basis vectors.\n\nThe two main types, Lagrange and Newton, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like convert(::Type, p) will not work. Use fit(Type, xs, p), as appropriate, instead.\n\n\n\n\n\n","category":"type"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Lagrange\nNewton","category":"page"},{"location":"#SpecialPolynomials.Lagrange","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Lagrange","text":"Lagrange(xs, [ws], coeffs, [var])\n\nLagrange interpolation of points (xáµ¢, fáµ¢) for i âˆˆ 0..n.\n\nxs, coeffs: the interpolating coordinates.\nws: weights used in the barycentric representation. (From SpecialPolynomials.lagrange_barycentric_weights or SpecialPolynomials.lagrange_barycentric_nodes_weights.)\nvar: the polynomial indeterminate\n\nExtended help\n\nThe Lagrange interpolation of points (xáµ¢, fáµ¢) for i âˆˆ 0:n is the polynomial p(x) = âˆ‘áµ¢ lâ±¼(x) fâ±¼.\n\nThe basis vectors lâ±¼(x) are 1 on xâ±¼ and 0 on xáµ¢ when i â‰  j. That is, lâ±¼(x) = Î _{i â‰  j}(x-xáµ¢)/Î _{i â‰ j}(xâ±¼-xáµ¢). These can be rewritten in terms of weights, wâ±¼, depending on the xáµ¢ only, yielding lâ±¼ = l(x) wâ±¼/(x - xâ±¼) with l(x) = Î (x-xáµ¢). Going further, yields the barycentric formula:\n\np(x) = (âˆ‘ wâ±¼ / (x - xâ±¼) â‹… fâ±¼) /  (âˆ‘ wâ±¼ / (x - xâ±¼) ).\n\nThis representation has several properties, as detailed in Berrut and Trefethen Barycentric Lagrange Interpolation.\n\nExamples\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))\n\njulia> p.([1,2,3]) # the coefficients\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> convert(Polynomial,  p)\nPolynomial(1.0*x)\n\nThe instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as variable or convert(Lagrange, ...). For the former we can use an instance, for the latter we can use fit:\n\njulia> p =  Lagrange([1,2,3], [1,2,3])\nLagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))\n\njulia> variable(p)\nLagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))\n\njulia> q = Polynomial([0,0,1])\nPolynomial(x^2)\n\njulia> qq = fit(Lagrange, p.xs, p.ws, q)\nLagrange(1â‹…â„“_0(x) + 4â‹…â„“_1(x) + 9â‹…â„“_2(x))\n\njulia> convert(Polynomial, qq)\nPolynomial(1.0*x^2)\n\nFor a given set of nodes, SpecialPolynomials.lagrange_barycentric_weights can compute the weights.  For all but modest values of n, interpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. (They should have asymptotic density of 1/âˆš(1-x^2) over [-1,1].) For P=Chebyshvev and P=ChebyshevU, the function SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n) will return a good choice of n+1 points over [-1,1] along with precomputed weights.\n\njulia> xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(SpecialPolynomials.ChebyshevBasis, 64);\n\n\njulia> f(x) = exp(-x)*sinpi(x)\nf (generic function with 1 method)\n\njulia> p = fit(Lagrange, xs, f.(xs));\n\n\njulia> degree(p)\n64\n\njulia> maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) <= 1e-14\ntrue\n\nnote: Note\nThe above example is more directly done through fit(Chebyshev, f, 64), though the resulting polynomial will reference a different basis.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.Newton","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Newton","text":"Newton{N,S,T,X}\n\nA Newton interpolating polynomial uses a basis 1, (x-x_0), (x-x_0)(x-x_1), ..., (x-x0)(x-x1)â‹…â‹…â‹…(x-x_{n-1}) and coefficients (in forward form) f[x_0], f[x_0,x_1], ...,f[x_0,...,x_n]. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.\n\nThe easiest way to construct an instance is with fit, as in:\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;\n\njulia> p = fit(Newton, xs, f)\nNewton(5.0â‹…p_1(x) + 6.0â‹…p_2(x) + 1.0â‹…p_3(x))\n\njulia> p.(xs) == f.(xs)  # p interpolates\ntrue\n\njulia> convert(Polynomial, p)\nPolynomial(1.0 - 2.0*x + 1.0*x^3)\n\n\n\n\n\n","category":"type"},{"location":"#Other-polynomials","page":"SpecialPolynomials.jl","title":"Other polynomials","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"Bernstein\nDualBernstein","category":"page"},{"location":"#SpecialPolynomials.Bernstein","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.Bernstein","text":"Bernstein{N, T, X}\n\nA Bernstein  polynomial is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, ð, this is a set of ð+1 degree ð polynomials of the form: Î²_{ð,Î½} =  (Î½ choose ð) x^Î½  (1-x)^{ð-Î½}, 0 â‰¤ x â‰¤ 1.\n\nThe Bernstein{ð,T} type represents a polynomial of degree ð or less with a linear combination of the basis vectors using coefficients of type T.\n\njulia> using Polynomials, SpecialPolynomials\n\njulia> p = basis(Bernstein{3},  2)\nBernstein(1â‹…Î²â‚ƒ,â‚‚(x))\n\njulia> convert(Polynomial, p)\nPolynomial(3.0*x^2 - 3.0*x^3)\n\nnote: Note\nStaticUnivariatePolynomials offers a  more  performant version.\n\n\n\n\n\n","category":"type"},{"location":"#SpecialPolynomials.DualBernstein","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.DualBernstein","text":"DualBernstein{N, Î±, Î², T, X}\n\nGiven the inner product <f,g> = âˆ«â‚€Â¹ (1-x)áµ… xáµ f(x) g(x) dx and the Bernstein polynomials Báµ¢â¿(x) the dual Bernstein polynomials satisfy <Báµ¢â¿, Dâ±¼â¿(x;Î±,Î²)> = Î´áµ¢â±¼\n\nExample\n\njulia> n,Î±,Î² = 5, 0, 0;\n\njulia> D = DualBernstein{n,Î±,Î²}\nDualBernstein{5, 0, 0}\n\njulia> bi = basis(D, 3)\nDualBernstein(1.0â‹…Î²áµ…áµâ‚…,â‚ƒ(x))\n\njulia> bi(0.2)\n7.910400000000036\n\nThe Bernstein-Bezier form of f minimizes the value of the least-square error for the Î±-Î² norm.\n\njulia> f(x) = sinpi(x);\n\njulia> n, Î±, Î² = 5, 1/2, 1/2\n(5, 0.5, 0.5)\n\njulia> B, D = Bernstein{n}, DualBernstein{n,Î±,Î²};\n\njulia> Iâ‚– = [ip(f, basis(D,k), Î±, Î²) for k in 0:n];\n\njulia> pâ‚™ = B(Iâ‚–);\n\njulia> Î» = x -> f(x) - pâ‚™(x);\n\njulia> SpecialPolynomials.innerproduct(ShiftedJacobi{Î±, Î²}, Î», Î»)\n0.00017514530881540565\n\nReference\n\nThe implementation follows that of Chudy and WoÅºny.\n\n\n\n\n\n","category":"type"},{"location":"#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-á´º-báµ¢Báµ¢(t)):","page":"SpecialPolynomials.jl","title":"Example of a Bezier curve (parameterized by r(t) = âˆ‘â‚€á´º báµ¢Báµ¢(t)):","text":"","category":"section"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"using Plots, Polynomials, SpecialPolynomials;  # hide\nbs = [[220, 260], [220, 40], [35, 100],  [120, 140]]\n\np = Bernstein(bs)\nts = range(0, stop=1, length=50)\nps = p.(ts)\nxs, ys = [[páµ¢[1] for páµ¢ âˆˆ ps], [páµ¢[2] for páµ¢ âˆˆ ps]]\np = plot(xs, ys, legend=false)\nscatter!(p, [b[1] for b in bs], [b[2] for b in bs])\nsavefig(\"bezier.svg\"); nothing  # hide","category":"page"},{"location":"","page":"SpecialPolynomials.jl","title":"SpecialPolynomials.jl","text":"(Image: )","category":"page"}]
}
