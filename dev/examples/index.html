<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · SpecialPolynomials</title><meta name="title" content="Examples · SpecialPolynomials"/><meta property="og:title" content="Examples · SpecialPolynomials"/><meta property="twitter:title" content="Examples · SpecialPolynomials"/><meta name="description" content="Documentation for SpecialPolynomials."/><meta property="og:description" content="Documentation for SpecialPolynomials."/><meta property="twitter:description" content="Documentation for SpecialPolynomials."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SpecialPolynomials logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SpecialPolynomials</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SpecialPolynomials.jl</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Construction"><span>Construction</span></a></li><li><a class="tocitem" href="#Polynomial-methods"><span>Polynomial methods</span></a></li><li><a class="tocitem" href="#Fitting"><span>Fitting</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SpecialPolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/master/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><ul></ul><h2 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h2><p>This package provides several  types to represent  polynomials relative  to different  bases from the standard polynomial  basis, <code>1</code>,<code>x</code>,<code>x²</code>, <code>x³</code> etc.</p><p>For example, the Legendre polynomials are a collection of polynomials on <code>[-1,1]</code>. The first few may be seen through:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p0 = Legendre([1])
Legendre(1⋅P₀(x))

julia&gt; p1 = Legendre([0,1])
Legendre(1⋅P₁(x))

julia&gt; p2 = Legendre([0,0,1])
Legendre(1⋅P₂(x))

julia&gt; p3 = Legendre([0,0,0,1])
Legendre(1⋅P₃(x))</code></pre><p>A plot recipe is useful for a graphical view:</p><pre><code class="language-julia hljs">n = 6
ψ₁, ψ₂, ψ₃, ψ₄, ψ₅, ψ₆ = basis.(Legendre, 0:n - 1)
kw = (xlabel=&quot;r&quot;, ylabel=&quot;ψₙ(r)&quot;)
sps = [
  plot( ψ₁, label=&quot;ψ₁(r)&quot;; kw...),
  plot( ψ₂, label=&quot;ψ₂(r)&quot;; kw...),
  plot( ψ₃, label=&quot;ψ₃(r)&quot;; kw...),
  plot( ψ₄, label=&quot;ψ₄(r)&quot;; kw...),
  plot( ψ₅, label=&quot;ψ₅(r)&quot;; kw...),
  plot( ψ₆, label=&quot;ψ₆(r)&quot;; kw...),
]
plot(sps..., layout=(3, 2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plot{Plots.GRBackend() n=6}</code></pre><p>The coefficients, e.g., <code>[0,0,0,1]</code> indicate a polynomial <code>0⋅p0 + 0⋅p1 + 0⋅p2 + 1⋅p3</code>. The <code>show</code> method expresses these polynomials relative to their bases. More familiar expressions are seen by conversion to the standard basis. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; convert.(Polynomial, [p0,p1,p2,p3])
4-element Vector{Polynomial{Float64, :x}}:
 Polynomial(1.0)
 Polynomial(1.0*x)
 Polynomial(-0.5 + 1.5*x^2)
 Polynomial(-1.5*x + 2.5*x^3)</code></pre><p>Polynomial instances are callable. We have, for example, to evaluate a polynomial at a set of points:</p><pre><code class="language-julia-repl hljs">julia&gt; p3.([1/4, 1/2, 3/4])
3-element Vector{Float64}:
 -0.3359375
 -0.4375
 -0.0703125</code></pre><p>Conversion can also be achieved through polynomial evaluation, using a variable <code>x</code> in the <code>Polynomial</code> basis:</p><pre><code class="language-julia-repl hljs">julia&gt; x = variable(Polynomial)
Polynomial(1.0*x)

julia&gt; p3(x)
Polynomial(-1.5*x + 2.5*x^3)</code></pre><p>Representation in another basis can be achieved this way:</p><pre><code class="language-julia-repl hljs">julia&gt; u = variable(ChebyshevU)
ChebyshevU(0.5⋅U₁(x))

julia&gt; p3(u)
ChebyshevU(- 0.125⋅U₁(x) + 0.3125⋅U₃(x))</code></pre><p>For most of the orthogonal polynomials, a conversion from the standard basis is provided, and a conversion between different parameter values  for the  same polynomial type are provided. Conversion methods between other polynomial types are not provided, but either evaluation, as above, or conversion through the <code>Polynomial</code> type is possible. As possible, for the orthogonal polynomial types, conversion utilizes the <code>FastTransforms</code> package; this package can handle conversion between polynomials with very high degree.</p><p>For the basis functions, the <code>basis</code> function can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; h0,h1,h2,h3 = basis.(Hermite, 0:3);

julia&gt; x = variable();

julia&gt; h3(x)
Polynomial(-12.0*x + 8.0*x^3)</code></pre><p>For numeric evaluation of just a basis polynomial of a classical orthogonal polynomial system, the <code>Basis</code> constructor provides a direct evaluation without the construction of an intermediate polynomial:</p><pre><code class="language-julia-repl hljs">julia&gt; Basis(Hermite, 3)(0.5)
-5.0</code></pre><p>!!! note &quot;Evaluation with <code>Basis</code> is not robust     The evaluation of a <code>Basis</code> object relies on a classical hypergeometric representation and for values of <span>$n$</span> as small as <span>$30$</span> can be very susceptible to round off error.</p><p>If the coefficients of a polynomial relative to the polynomial type are known, they can be directly passed to the constructor:</p><pre><code class="language-julia-repl hljs">julia&gt; Laguerre{0}([1,2,3])
typename(Laguerre){0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))</code></pre><p>Some polynomial types are parameterized, as above. The parameters are passed to the type, as in this example:</p><pre><code class="language-julia-repl hljs">julia&gt; Jacobi{1/2, -1/2}([1,2,3])
typename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))</code></pre><hr/><p>The polynomial types specified above are orthogonal, meaning the inner product of different basis vectors will be 0. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; using QuadGK


julia&gt; P = Legendre
Legendre

julia&gt; p4,p5 = basis.(P, [4,5])
2-element Vector{Legendre{Float64, :x}}:
 Legendre(1.0⋅P₄(x))
 Legendre(1.0⋅P₅(x))

julia&gt; wf, dom = SpecialPolynomials.weight_function(P), Polynomials.domain(P);

julia&gt; quadgk(x -&gt; p4(x) * p5(x) *  wf(x), first(dom), last(dom))
(0.0, 0.0)</code></pre><p>The unexported <code>innerproduct</code> will compute this as well, without the need to specify the domain or weight function, which can be gleaned from the type.</p><pre><code class="language-julia-repl hljs">julia&gt; SpecialPolynomials.innerproduct(P, p4, p5)
-1.5309832087675112e-16</code></pre><h2 id="Polynomial-methods"><a class="docs-heading-anchor" href="#Polynomial-methods">Polynomial methods</a><a id="Polynomial-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-methods" title="Permalink"></a></h2><p>For each polynomial type, this package implements as many of the methods for polynomials defined in <code>Polynomials</code>, as possible.</p><h3 id="Evaluation"><a class="docs-heading-anchor" href="#Evaluation">Evaluation</a><a id="Evaluation-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluation" title="Permalink"></a></h3><p>Evaluation, as seen, is done through making polynomial objects callable:</p><pre><code class="nohighlight hljs">julia&gt; P = Chebyshev
Chebyshev

julia&gt; p = P([1,2,3,4])
Chebyshev(1⋅T₀(x) + 2⋅T₁(x) + 3⋅T₂(x) + 4⋅T₃(x))

julia&gt; p(0.4)
-4.016</code></pre><p>By default, for classical orthogonal polynomials,  the Clenshaw reduction formula is used. For such polynomials, an alternative is to use the hypergeometric formulation. (The evaluation <code>Basis(P,n)(x)</code> uses this.) There is an unexported method to compute through this means:</p><pre><code class="nohighlight hljs">julia&gt; SpecialPolynomials.eval_hyper(P, coeffs(p),  0.4)
-4.016</code></pre><h3 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h3><p>For example, basic arithmetic operations  are defined:</p><pre><code class="nohighlight hljs">julia&gt; P = ChebyshevU
ChebyshevU

julia&gt; p,q = P([1,2,3,4]), P([-2,0,1,2])
(ChebyshevU(1⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x)), ChebyshevU(- 2⋅U_0(x) + 1⋅U_2(x) + 2⋅U_3(x)))

julia&gt; p + 1
ChebyshevU(2⋅U_0(x) + 2⋅U_1(x) + 3⋅U_2(x) + 4⋅U_3(x))

julia&gt; -p
ChebyshevU(- 1⋅U_0(x) - 2⋅U_1(x) - 3⋅U_2(x) - 4⋅U_3(x))

julia&gt; p + q
ChebyshevU(- 1⋅U_0(x) + 2⋅U_1(x) + 4⋅U_2(x) + 6⋅U_3(x))

julia&gt; p*q
ChebyshevU(9⋅U_0(x) + 8⋅U_1(x) + 10⋅U_2(x) + 6⋅U_3(x) + 15⋅U_4(x) + 10⋅U_5(x) + 8⋅U_6(x))

julia&gt; p^2
ChebyshevU(30⋅U_0(x) + 40⋅U_1(x) + 51⋅U_2(x) + 44⋅U_3(x) + 41⋅U_4(x) + 24⋅U_5(x) + 16⋅U_6(x))</code></pre><p>Multiplication formulas may not be defined for each type, and a fall back may be used where the multiplication is done with respect to the standard basis and the answer re-represented:</p><pre><code class="language-julia-repl hljs">julia&gt; P = Jacobi{1/2, -1/2}
Jacobi{0.5, -0.5}

julia&gt; p,q = P([1,2]), P([-2,1])
(typename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), typename(Jacobi){0.5,-0.5}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))

julia&gt; p * q
typename(Jacobi){0.5,-0.5}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))</code></pre><h3 id="Derivatives-and-integrals"><a class="docs-heading-anchor" href="#Derivatives-and-integrals">Derivatives and integrals</a><a id="Derivatives-and-integrals-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives-and-integrals" title="Permalink"></a></h3><p>The classic continuous orthogonal polynomials  have  the <code>derivative</code>  and <code>integrate</code> methods defined:</p><pre><code class="language-julia-repl hljs">julia&gt; P = ChebyshevU{Float64}
ChebyshevU{Float64}

julia&gt; p = P([1,2,3])
ChebyshevU(1.0⋅U₀(x) + 2.0⋅U₁(x) + 3.0⋅U₂(x))

julia&gt; dp = derivative(p)
ChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))

julia&gt; convert.(Polynomial, (p, dp))
(Polynomial(-2.0 + 4.0*x + 12.0*x^2), Polynomial(4.0 + 24.0*x))

julia&gt; P = Jacobi{1//2, -1//2}
Jacobi{1//2, -1//2}

julia&gt; p,q = P([1,2]), P([-2,1])
(typename(Jacobi){1//2,-1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x)), typename(Jacobi){1//2,-1//2}(- 2⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x)))

julia&gt; p * q # as above, only with rationals for parameters
typename(Jacobi){1//2,-1//2}(- 1.5⋅Jᵅᵝ₀(x) - 2.0⋅Jᵅᵝ₁(x) + 1.3333333333333333⋅Jᵅᵝ₂(x))

julia&gt; P = Jacobi{1//2, 1//2}
Jacobi{1//2, 1//2}

julia&gt; p = P([1,2,3])
typename(Jacobi){1//2,1//2}(1⋅Jᵅᵝ₀(x) + 2⋅Jᵅᵝ₁(x) + 3⋅Jᵅᵝ₂(x))

julia&gt; dp = derivative(p)
typename(Jacobi){1//2,1//2}(3.0⋅Jᵅᵝ₀(x) + 10.0⋅Jᵅᵝ₁(x))

julia&gt; integrate(p)
typename(Jacobi){1//2,1//2}(0.24999999999999994⋅Jᵅᵝ₁(x) + 0.6⋅Jᵅᵝ₂(x) + 0.5714285714285714⋅Jᵅᵝ₃(x))

julia&gt; integrate(p, 0, 1)
3.125</code></pre><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>Expressing a polynomial in type <code>P</code> in type <code>Q</code> is done through several possible means:</p><pre><code class="language-julia-repl hljs">julia&gt; P,Q = Gegenbauer{1//3}, Gegenbauer{2//3}
(Gegenbauer{1//3}, Gegenbauer{2//3})

julia&gt; p = P([1,2,3.0])
typename(Gegenbauer){1//3}(1.0⋅Cᵅ₀(x) + 2.0⋅Cᵅ₁(x) + 3.0⋅Cᵅ₂(x))

julia&gt; convert(Q, p)
typename(Gegenbauer){2//3}(0.8⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.2⋅Cᵅ₂(x))

julia&gt; p(variable(Q))
typename(Gegenbauer){2//3}(0.7999999999999999⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.1999999999999997⋅Cᵅ₂(x))

julia&gt; SpecialPolynomials._convert_cop(Q,p)
typename(Gegenbauer){2//3}(0.8⋅Cᵅ₀(x) + 1.0⋅Cᵅ₁(x) + 1.2⋅Cᵅ₂(x))</code></pre><p>The first uses a method from the <code>FastTransforms</code> package (when loaded). This package can handle polynomials of very high degree. It is used by default, as much as possible. The second uses polynomial evaluation (Clenshaw evaluation) to perform the conversion. The third uses the structural equations for conversion, when possible, and defaults to converting through the <code>Polynomial</code> type</p><h3 id="Roots"><a class="docs-heading-anchor" href="#Roots">Roots</a><a id="Roots-1"></a><a class="docs-heading-anchor-permalink" href="#Roots" title="Permalink"></a></h3><p>The <code>roots</code> function finds the roots of a polynomial</p><pre><code class="language-julia-repl hljs">julia&gt; p = Legendre([1,2,2,1])
Legendre(1⋅P₀(x) + 2⋅P₁(x) + 2⋅P₂(x) + 1⋅P₃(x))

julia&gt; rts = roots(p); rts ≈ [-1, -1/5, 0]
true

julia&gt; maximum(abs∘p, rts) &lt;= 10eps() # small residual
true</code></pre><p>Here we see <code>fromroots</code> and <code>roots</code> are related, provided a monic polynomial is used:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; P = Jacobi{1/2,-1/2}
Jacobi{0.5, -0.5}


julia&gt; p = P([1,1,2,3])
typename(Jacobi){0.5,-0.5}(1⋅Jᵅᵝ₀(x) + 1⋅Jᵅᵝ₁(x) + 2⋅Jᵅᵝ₂(x) + 3⋅Jᵅᵝ₃(x))

julia&gt; q = SP.monic(p) # monic is not exported
typename(Jacobi){0.5,-0.5}(0.13333333333333333⋅Jᵅᵝ₀(x) + 0.13333333333333333⋅Jᵅᵝ₁(x) + 0.26666666666666666⋅Jᵅᵝ₂(x) + 0.4⋅Jᵅᵝ₃(x))

julia&gt; fromroots(P, roots(q)) - q |&gt; u -&gt; truncate(u, atol=sqrt(eps()))
typename(Jacobi){0.5,-0.5}(0.0 + 0.0im)</code></pre><p>For many of the orthogonal polynomials, the roots are found from the <em>comrade matrix</em> using a <span>$\mathcal{O}(n^2)$</span> algorithm of Aurentz, Vandebril, and Watkins, which computes in a more efficient manner the <code>eigvals(SpecialPolynomials.comrade_matrix(p))</code>. Alternatively, in theory roots may be identified from the companion matrix of the polynomial, once expressed in the standard basis. This approach is the fallback approach for other polynomial types, but is prone to numeric issues.</p><p>For orthogonal polynomials, the roots of the basis vectors are important for quadrature. For larger values of <code>n</code>, the eigenvalues of the unexported <code>jacobi_matrix</code> also identify these roots, but the algorithm is more stable than conversion to the standard basis</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; round′(p) = map(x -&gt; round(x, digits=6), p)
round′ (generic function with 1 method)

julia&gt; p4 = basis(Legendre, 4)
Legendre(1.0⋅P₄(x))

julia&gt; roots(p4) .|&gt; real .|&gt; round′
4-element Vector{Float64}:
 -0.861136
 -0.339981
  0.339981
  0.861136

julia&gt; eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 4)) .|&gt; x -&gt; round(x, digits=10)
4-element Vector{Float64}:
 -0.8611363116
 -0.3399810436
  0.3399810436
  0.8611363116</code></pre><p>At higher degrees, the difference in  stability comes out. For the special case of a basis polynomial, we see this difference in the maximum residual:</p><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra

julia&gt; p50 = basis(Legendre{Float64}, 50)
Legendre(1.0⋅P₅₀(x))

julia&gt; as = eigvals(Polynomials.companion(p50));

julia&gt; maximum(abs ∘ p50, as) &lt; sqrt(eps())
false

julia&gt; bs = eigvals(SpecialPolynomials.jacobi_matrix(Legendre, 50 ));

julia&gt; maximum(abs ∘ p50, bs) &lt; sqrt(eps())
true

julia&gt; maximum(abs, roots(p50) - bs) &lt; sqrt(eps())
true</code></pre><p>(The roots of the classic orthogonal polynomials  are  all  real  and distinct.)</p><p>The unexported <code>gauss_nodes_weights</code> function returns the nodes and weights. For many types (e.g., <code>Jacobi</code>, <code>Legendre</code>, <code>Hermite</code>, <code>Laguerre</code>). As possible, it uses the methods from the <code>FastGaussQuadratures</code> package, which provides <code>O(n)</code> algorithms, where the Jacobi matrix is <code>O(n²)</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; xs, ws = SpecialPolynomials.gauss_nodes_weights(Legendre, 4)
([-0.86113631159405, -0.33998104358485537, 0.33998104358485715, 0.8611363115940526], [0.34785484513745607, 0.6521451548625448, 0.652145154862546, 0.3478548451374536])

julia&gt; basis(Legendre, 4).(xs)
4-element Vector{Float64}:
 -1.199040866595169e-14
  1.6930901125533637e-15
 -1.6653345369377348e-15
  1.1102230246251565e-16

julia&gt; f(x) = x^7 - x^6; F(x) = x^8/8 - x^7/7;

julia&gt; sum(f(x)*w for (x,w) in zip(xs, ws)) - (F(1) - F(-1))
3.3306690738754696e-15</code></pre><h2 id="Fitting"><a class="docs-heading-anchor" href="#Fitting">Fitting</a><a id="Fitting-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting" title="Permalink"></a></h2><h3 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h3><p>For any set of points <code>(x0,y0), (x1,y1), ..., (xn, yn)</code> with unique <code>x</code> values,  there is a unique polynomial of degree <code>n</code> or less that <em>interpolates</em> these points, that is  <code>p(x_i) = y_i</code>. The  <code>fit</code> function will perform polynomial interpolation:</p><pre><code class="language-julia-repl hljs">julia&gt; xs, ys = [0, 1/4,  1/2,  3/4], [1,2,2,3]
([0.0, 0.25, 0.5, 0.75], [1, 2, 2, 3])

julia&gt; p1 = fit(Polynomial,  xs, ys) |&gt; round′
Polynomial(1.0 + 8.666667*x - 24.0*x^2 + 21.333333*x^3)</code></pre><p>The <code>Lagrange</code> and <code>Newton</code> types represent the polynomial in convenient bases based on the nodes (<code>xs</code>):</p><pre><code class="language-julia-repl hljs">julia&gt; p2 = fit(Lagrange, xs, ys)
Lagrange(1⋅ℓ_0(x) + 2⋅ℓ_1(x) + 2⋅ℓ_2(x) + 3⋅ℓ_3(x))

julia&gt; p3 = fit(Newton, xs, ys)
Newton(1.0⋅p_0(x) + 4.0⋅p_1(x) - 8.0⋅p_2(x) + 21.333333333333332⋅p_3(x))</code></pre><p>These all represent the same interpolating polynomial:</p><pre><code class="language-julia-repl hljs">julia&gt; [p1.(xs)-ys  p2.(xs)-ys p3.(xs)-ys]
4×3 Matrix{Float64}:
 0.0         0.0  0.0
 7.8125e-8   0.0  0.0
 1.25e-7     0.0  0.0
 1.09375e-7  0.0  0.0</code></pre><p>The <code>Lagrange</code> and <code>Newton</code>  methods allow a function to be specified  in place  of a set of <code>y</code> values:</p><pre><code class="language-julia-repl hljs">julia&gt; p = fit(Newton, [1,2,3], x-&gt;x^2)
Newton(1.0⋅p_0(x) + 3.0⋅p_1(x) + 1.0⋅p_2(x))

julia&gt; convert(Polynomial, p)
Polynomial(1.0*x^2)</code></pre><p>Polynomial interpolation can demonstrate the Runge phenomenon if the nodes are evenly spaced and <code>n</code> is large enough. For higher degree fitting, the choice of nodes can greatly effect the approximation of the interpolating polynomial to the function generating the <code>y</code> values. The <code>SpecialPolynomials.lagrange_barycentric_nodes_weights</code> function returns nodes (and accompanying weights) for different polynomial types.</p><p>For an orthogonal polynomial type, the zeros of the basis polynomial <code>p_{n+1}</code>, labeled <code>x_0, x_1, ..., x_n</code> are often used as nodes, especially for the Chebyshev nodes (of the first kind).  <a href="https://archive.siam.org/books/ot99/OT99SampleChapter.pdf">Gil, Segura, and Temme</a> say &quot;Interpolation with Chebyshev nodes is not as good as the best approximation ..., but usually it is the best practical possibility for interpolation and certainly much better than equispaced interpolation&quot;</p><p>For the orthogonal polynomial types, the default for <code>fit</code> for degree <code>n</code> will use the zeros of <code>P_{n+1}</code> to interpolate.</p><p>We can see that some interpolation points lead to better fits than others, in the following graphic:</p><pre><code class="language-julia hljs">f(x) = exp(-x)*sinpi(x)
plot(f, -1, 1, legend=false, color=:black, linewidth=3)
p=fit(Val(:interpolating), Chebyshev, f, 3); plot!(p, color=:blue)
p=fit(Val(:interpolating), ChebyshevU, f, 3); plot!(p, color=:red)
fit(Val(:interpolating), Legendre, f, 3); plot!(p, color=:green)
xs = [-0.5, 0.0, 0.5]
p=fit(Newton, xs, f);
ts = range(-1, 1, length=100); plot!(ts, p.(ts), color=:brown)</code></pre><p><img src="../fitting.svg" alt/></p><h3 id="Polynomial-approximation"><a class="docs-heading-anchor" href="#Polynomial-approximation">Polynomial approximation</a><a id="Polynomial-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-approximation" title="Permalink"></a></h3><p>There are other criteria for fitting that can be used.</p><p>If there are a lot of points, it is common  to  fit with a  lower  degree polynomial. This won&#39;t  be an interpolating polynomial, in general. The criteria  used to select the polynomial is  typically least squares (weighted least squares is also available). Fitting  ini the standard basis, a  degree  is specified, as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; xs, ys =  [1,2,3,4], [2.0,3,1,4]
([1, 2, 3, 4], [2.0, 3.0, 1.0, 4.0])

julia&gt; p1 =  fit(Polynomial, xs,  ys, 1) |&gt; round′ # degree 1  or less
Polynomial(1.5 + 0.4*x)

julia&gt; p1 =  fit(Polynomial, xs,  ys, 2) |&gt; round′ # degree 2 or less
Polynomial(4.0 - 2.1*x + 0.5*x^2)

julia&gt; p1 =  fit(Polynomial, xs,  ys) |&gt; round′    # degree 3 or less (length(xs) - 1)
Polynomial(-10.0 + 20.166667*x - 9.5*x^2 + 1.333333*x^3)</code></pre><p>For the orthogonal polynomial types, fitting a polynomial to a function using least squares can be solved using the polynomial <code>a0⋅p0 + a1⋅p1 + ⋅⋅⋅ + an⋅pn</code> where <code>ai=∫f⋅pi⋅w⋅dx / ∫pi^2⋅w⋅dx</code>. There is no need to specify values for <code>x</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = exp(-x) * sinpi(x)
f (generic function with 1 method)

julia&gt; p = fit(Val(:lsq), Chebyshev{Float64}, f, 50);

julia&gt; maximum(norm(p(x)-f(x) for x in range(-1,1,length=500))) &lt;= sqrt(eps())
true</code></pre><p>This wavy example is from Trefethen:</p><pre><code class="language-julia-repl hljs">julia&gt; f(x) = sin(6x) + sin(60*exp(x))
f (generic function with 1 method)

julia&gt; p50 = fit(Val(:lsq), Chebyshev{Float64}, f, 50);

julia&gt; maximum(norm(p50(x)-f(x) for x in range(-1,1,length=500))) &lt;= sqrt(eps()) # cf. graph below
false</code></pre><p>(With 50 points, the approximation misses badly over <code>[-1,1]</code>. There are 45 local extrema on  this interval.)</p><p>However, with more points we have a good fit:</p><pre><code class="language-julia-repl hljs">julia&gt; p196 = fit(Chebyshev{Float64}, f, 196);

julia&gt; maximum(norm(p196(x)-f(x) for x in range(-1,1,length=500))) &lt;= sqrt(eps())  # ≈ 1e-13
true</code></pre><pre><code class="language-julia hljs">f(x) = sin(6x) + sin(60*exp(x))
p50 = fit(Chebyshev{Float64}, f, 50);
p196 = fit(Chebyshev{Float64}, f, 196);
plot(f, -1, 1, legend=false, color=:black)
xs = range(-1, stop=1, length=500) # more points than recipe
plot!(xs, p50.(xs), color=:blue)
plot!(xs, p196.(xs), color=:red)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plot{Plots.GRBackend() n=3}</code></pre><p><img src="../wavy.svg" alt/> # hide</p><p>For the  <code>Chebyshev</code> type, the  <code>Val(:series)</code> argument will fit a heuristically identify truncated series  to the function.</p><pre><code class="nohighlight hljs">using Polynomials, SpecialPolynomials
f(x) = sin(6x) + sin(60*exp(x))
p = fit(Val(:series), Chebyshev, f);
degree(p)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <a href="https://github.com/JuliaApproximation/ApproxFun.jl">ApproxFun</a> package provides a framework to quickly and accuratately approximate functions using certain polynomial types. The choice of order and methods for most of Julia&#39;s built-in functions are conveniently provided.</p></div></div><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>The <code>plot</code> recipe from the <code>Polynomials</code> package works as expected for the polynomial types in this package. The domain to be plotted over matches that given by <code>Polynomials.domain</code>, unless this is infinite.</p><p>A plot of the first few Chebyshev Polynomials of the second kind can be produced as follows:</p><pre><code class="language-julia hljs"># U1, U2, U3, and U4:
chebs  = basis.(ChebyshevU, 1:4)
colors = [&quot;#4063D8&quot;, &quot;#389826&quot;, &quot;#CB3C33&quot;, &quot;#9558B2&quot;]
p = plot(legend=false)
for (cheb, col) in zip(chebs, colors)
  plot!(p, cheb, c=col, lw=5)
end</code></pre><p><img src="../chebs.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« SpecialPolynomials.jl</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 28 March 2025 17:01">Friday 28 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
