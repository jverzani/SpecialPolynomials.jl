<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SpecialPolynomials.jl Â· SpecialPolynomials</title><meta name="title" content="SpecialPolynomials.jl Â· SpecialPolynomials"/><meta property="og:title" content="SpecialPolynomials.jl Â· SpecialPolynomials"/><meta property="twitter:title" content="SpecialPolynomials.jl Â· SpecialPolynomials"/><meta name="description" content="Documentation for SpecialPolynomials."/><meta property="og:description" content="Documentation for SpecialPolynomials."/><meta property="twitter:description" content="Documentation for SpecialPolynomials."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="SpecialPolynomials logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>SpecialPolynomials</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SpecialPolynomials.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Orthogonal-polynomials"><span>Orthogonal polynomials</span></a></li><li><a class="tocitem" href="#Implemented-polynomial-types"><span>Implemented polynomial  types</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SpecialPolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ï‚›</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ï„</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SpecialPolynomials.jl"><a class="docs-heading-anchor" href="#SpecialPolynomials.jl">SpecialPolynomials.jl</a><a id="SpecialPolynomials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SpecialPolynomials.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jverzani/SpecialPolynomials.jl">SpecialPolynomials.jl</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This package provides a number of different polynomial types to represent polynomials, extending the <code>Polynomials</code> package.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.AbstractSpecialPolynomial" href="#SpecialPolynomials.AbstractSpecialPolynomial"><code>SpecialPolynomials.AbstractSpecialPolynomial</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractSpecialPolynomial{T,X}</code></pre><p>An abstract type to distinguish the different polynomial types in this package.</p><p>The concrete types specify different bases for the space of polynomials of degree <code>n</code> or less.</p><p>This package includes:</p><ul><li>several classic orthogonal polynomials.</li><li>Newton and Lagrange interpolating polynomials</li><li>Bernstein polynomials</li></ul><p>As many of the methods for the base <code>Polynomials</code> class are directly coded if possible, but quite a few depend on conversion to the base <code>Polynomial</code> type (which uses the standard polynomial basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/abstract.jl#L1-L17">source</a></section></article><h2 id="Orthogonal-polynomials"><a class="docs-heading-anchor" href="#Orthogonal-polynomials">Orthogonal polynomials</a><a id="Orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.AbstractOrthogonalPolynomial" href="#SpecialPolynomials.AbstractOrthogonalPolynomial"><code>SpecialPolynomials.AbstractOrthogonalPolynomial</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractOrthogonalPolynomial{T,X}</code></pre><p>Type to represent systems of orthogonal polynomials. These polynomials have  several properties, including an accompanying inner product satisfying  <code>âŸ¨yáµ¢, yâ±¼âŸ© = cáµ¢Î´áµ¢â±¼</code>.</p><p>In addition to methods inherited from the underlying <code>AbstractPolynomial</code>  type, orthogonal polynomial  types may have methods   <code>weight_function</code>, <code>generating_function</code>, <code>leading_term</code>, <code>norm2</code>, <code>jacobi_matrix</code>, and <code>gauss_nodes_weights</code>,  though none are  exported.</p><p>Subtypes of <code>AbstractCOP &lt;: AbstractOrthogonalPolynomial</code> utilize the fact that the basis  polynomials  satisfy</p><p><code>(axÂ² + bx + c)yáµ¢&#39;&#39;(x) + (dx+e)yáµ¢&#39;(x) + Î»áµ¢yáµ¢(x) = 0</code> (or a discrete analogue)</p><p>where the structural relations are functions of <code>a,b,c,d,e</code>. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the <code>Polynomial</code> type (the <code>FallingFactorial</code> type in the discrete  c case),</p><p>A key structural relation is the three-term recursion,  <code>yáµ¢â‚Šâ‚ =  (Aáµ¢x +  Báµ¢)yáµ¢ -  Cáµ¢yáµ¢â‚‹â‚</code>. For systems  specified by  a  weight function, the  values of <code>Aáµ¢</code>, <code>Báµ¢</code>, and <code>Cáµ¢</code> can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the <code>Polynomial</code>  type through evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.AbstractCCOP" href="#SpecialPolynomials.AbstractCCOP"><code>SpecialPolynomials.AbstractCCOP</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractCCOP{T,X} &lt;:  AbstractCOP{T,X}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a>, a family <code>y(x)=p_n(x)=k_xâ‹…x^n +  ...</code> for  <code>n  âˆˆ  {0, 1,â€¦}, k_n â‰  0</code> of polynomials is a family of classic <em>continuous</em> orthogonal polynomials if each is  a solution of the differential equation</p><p><code>(aâ‹…xÂ²+bâ‹…x+c) â‹… yáµ¢&#39;&#39; + (dâ‹…x + e) â‹… yáµ¢&#39; + Î»áµ¢â‹… yáµ¢ = 0.</code></p><p>A family is characterized, up to choice of leading term, by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>Ïƒ = (aâ‹…xÂ²+bâ‹…x+c)</code>, <code>Ï„ = (dâ‹…x + e)</code>.</p><p>From these  5  coefficients several structural  equations are represented. For example the three-point recursion.</p><p><code>Pâ‚áµ¢â‚Šâ‚â‚ = (Aáµ¢â‹…x + Báµ¢) * Páµ¢ - Cáµ¢ *  Pâ‚áµ¢â‚‹â‚â‚</code>,</p><p>where <code>Aáµ¢,Báµ¢,Cáµ¢</code> can be represented in formulas involving just  <code>a,b,c,d,e</code> and <code>i</code>.</p><p>Rearranging   gives the structural equation:</p><p><code>xâ‹…p_n   = [an, bn, cn] â‹… [p_{n+1}, p_n, p_{n-1}]</code>  (Eqn (7))</p><p>The other structural equations are (equation  references are from Koepf and Schmersau):</p><p><code>Ïƒâ‹…p&#39;_n  = [Î±n, Î²n, Î³n] â‹…  [p_{n+1}, p_n, p_{n-1}]</code> (Eqn (9), n â‰¥ 1)</p><p><code>p_n = [aÌ‚n, bÌ‚n, cÌ‚n]  â‹…  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn (19))</p><p><code>xâ‹…p&#39;_n  = [Î±á´µn, Î²á´µn, Î³á´µn] â‹…  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn  (14))</p><p>Using (7), Clenshaw polynomial evaluation using the three  point recursion is defined.</p><p>Using (19), expressions for derivatives are found.</p><p>Using  (19), expressions for integration are found (p7).</p><p>Using their theorems 2,4, and 5, connection coefficients, <code>C(n,m)</code> satisfying <code>P_n(x) =  âˆ‘  C(n,m)  Q_m(x) (n â‰¥ 0, 0 â‰¤  m â‰¤ n)</code> are  found. These allow  fallback  definitions for <code>convert(Polynomial,p)</code>,  <code>convert(P, p::Polynomial)</code>, <code>convert(P{Î±â€¦}, p::P(Î²â€¦))</code> and through composition polynomial  multiplication,  <code>p*q</code>.</p><p>Subtypes of <code>AbstractCCOP</code> are  created through  the <code>@register0</code> or  <code>@registerN</code> macros, where the  <code>N</code>  macro  is used  if parameters are  needed to describe the family.</p><p>If non-monic versions are desired, then the  leading  term can be  specified through <code>kn()</code> (which by default is defined by the  method <code>k1k0(P,i)</code>, the ratio of  <code>káµ¢â‚Šâ‚/káµ¢</code>).  The <code>@register_monic</code> macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the <code>@register_shifted</code> macro is useful  to provide shifted versions (cf. <a href="#SpecialPolynomials.ShiftedLegendre"><code>ShiftedLegendre</code></a>).</p><p>Registering a system, defining an <code>abcde</code> method, and optionally defining <code>k1k0</code> is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.</p><p>The defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. <code>Chebyshev</code>,<code>ChebyshevU</code>, <code>Hermite</code>, <code>Laguerre</code>), but not all.</p><p><strong>Example</strong></p><p>For this example, the value of <code>Bn</code> at <code>0</code> needs help:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 MonicLegendreâ€² SP.AbstractCCOP0

julia&gt; SP.:ÏŸ(::Type{&lt;:MonicLegendreâ€²}) = Legendre

julia&gt; SP.@register_monic MonicLegendreâ€²  # use  ÏŸ to delegate methods

julia&gt; ğ  =  Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{ğ})
Polynomial(x)

julia&gt; [basis(MonicLegendreâ€²{ğ}, i)(x) for i  in 0:5]
6-element Vector{Polynomial{T, :x} where T}:
 Polynomial(1//1)
 Polynomial(1.0*x)
 Polynomial(-0.3333333333333333 + 1.0*x^2)
 Polynomial(-0.6*x + 1.0*x^3)
 Polynomial(0.0857142857142857 - 0.857142857142857*x^2 + 1.0*x^4)
 Polynomial(0.23809523809523805*x - 1.111111111111111*x^3 + 1.0*x^5)</code></pre><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/ccop.jl#L6-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.AbstractCDOP" href="#SpecialPolynomials.AbstractCDOP"><code>SpecialPolynomials.AbstractCDOP</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> AbstractCDOP{T,X} &lt;: AbstractCOP{T,X}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf  and Schmersau</a>, a family <code>y(x)=p_n(x)=k_xâ‹…x^n +  ...</code> for  <code>n  âˆˆ  {0, 1,â€¦}, k_n â‰  0</code> of polynomials is a family of classic <em>discrete</em> orthogonal polynomials if it  is  a solution of a differential equation</p><p><code>(aâ‹…xÂ²+bâ‹…x+c) â‹… Î”âˆ‡y + (dâ‹…x + e) â‹… âˆ‡&#39; + Î»áµ¢â‹… y = 0</code>,</p><p>where  <code>Î”y(x) = y(x+1) - y(x)</code> and <code>âˆ‡y(x) = y(x) - y(x-1)</code>.</p><p>A family is characterized by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>Ïƒ = (aâ‹…xÂ²+bâ‹…x+c)</code>, <code>Ï„ = (dâ‹…x + e).</code></p><p>As in the classical-continuous-orthogonal-polynomial case <a href="#SpecialPolynomials.AbstractCCOP"><code>AbstractCCOP</code></a>, from these 5 values the coefficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.</p><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials.</p><p>For example, on p29 they give  formulas for Hahn polynomials through:</p><p><code>n(n+Î±+Î²+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1)</code>,  with  explicit values  for  <code>B</code> and <code>D</code>. Reexpressing gives: <code>BÎ”y(x) - Dâˆ‡y(x) -Î» y(x)  = 0</code>. From the rexpressed Eqn (4) for Koepf &amp; Schemersau we have the identification: <code>Ïƒ+Ï„ =  B; Ïƒ=D</code>,  so  <code>Ï„=B-D</code>. From this <code>a,b,c,d,e</code> can be  gleaned.</p><p>The above, is termed the eigenvalue equation (e.g. <a href="https://arxiv.org/pdf/1609.07291.pdf">Goertz and Offner</a>), as it can be reexpressed as</p><p><code>Î”(D(x)â‹…Ï‰(x)â‹…âˆ‡yáµ¢(x) = Î»áµ¢â‹…Ï‰(x)â‹…yáµ¢(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/cdop.jl#L4-L41">source</a></section></article><h2 id="Implemented-polynomial-types"><a class="docs-heading-anchor" href="#Implemented-polynomial-types">Implemented polynomial  types</a><a id="Implemented-polynomial-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-polynomial-types" title="Permalink"></a></h2><h3 id="Classical-continuous-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-continuous-orthogonal-polynomials">Classical continuous orthogonal polynomials</a><a id="Classical-continuous-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-continuous-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical continuous  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Legendre" href="#SpecialPolynomials.Legendre"><code>SpecialPolynomials.Legendre</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Legendre{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre</a> polynomials. These have weight function <code>w(x) = 1</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Legendre([1,2,3])
Legendre(1â‹…Pâ‚€(x) + 2â‹…Pâ‚(x) + 3â‹…Pâ‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.5 + 2.0*x + 4.5*x^2)

julia&gt; p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k
(Legendre(1.0â‹…Pâ‚ˆ(x)), Legendre(1.0â‹…Pâ‚‰(x)))

julia&gt; p2m(-1) == 1
false

julia&gt; p2m1(-1) == -1
false

julia&gt; n = 5  # verify  Rodrigues&#39; formula
5

julia&gt; x = Polynomial(:x)
Polynomial(1.0*x)

julia&gt; derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)
Polynomial(0.0)

julia&gt; p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  Pâ‚„,Pâ‚…
(Legendre(1.0â‹…Pâ‚„(x)), Legendre(1.0â‹…Pâ‚…(x)))

julia&gt; SpecialPolynomials.innerproduct(Legendre, p4,  p5)
-1.5309832087675112e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Legendre.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Chebyshev" href="#SpecialPolynomials.Chebyshev"><code>SpecialPolynomials.Chebyshev</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Chebyshev{&lt;:Number}(coeffs::AbstractVector, var=:x)</code></pre><p>Chebyshev polynomial of the first kind.</p><p>Construct a polynomial from its coefficients <code>a</code>, lowest order first, optionally in terms of the given variable <code>x</code>. <code>x</code> can be a character, symbol, or string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; Chebyshev([1, 0, 3, 4])
Chebyshev(1â‹…Tâ‚€(x) + 3â‹…Tâ‚‚(x) + 4â‹…Tâ‚ƒ(x))

julia&gt; Chebyshev([1, 2, 3, 0], :s)
Chebyshev(1â‹…Tâ‚€(s) + 2â‹…Tâ‚(s) + 3â‹…Tâ‚‚(s))

julia&gt; one(Chebyshev)
Chebyshev(1.0â‹…Tâ‚€(x))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is copied from the <code>ChebyshevT</code> example from the <code>Polynomials</code> package by Miles Lucas.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The sample chapter available online of <a href="https://archive.siam.org/books/ot99/OT99SampleChapter.pdf">Numerical Methods for Special Functions&quot; by Amparo Gil, Javier Segura, and Nico Temme</a> gives a very nice overview of these polynomials.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Chebyshev.jl#L4-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.ChebyshevU" href="#SpecialPolynomials.ChebyshevU"><code>SpecialPolynomials.ChebyshevU</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChebyshevU{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev</a> polynomials of the second kind. These have weight function <code>w(x) = sqrt(1-x^2)</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = ChebyshevU([1,2,3])
ChebyshevU(1â‹…Uâ‚€(x) + 2â‹…Uâ‚(x) + 3â‹…Uâ‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(-2.0 + 4.0*x + 12.0*x^2)

julia&gt; derivative(p)
ChebyshevU(4.0â‹…Uâ‚€(x) + 12.0â‹…Uâ‚(x))

julia&gt; roots(p)
2-element Vector{ComplexF64}:
 -0.6076252185107651 + 0.0im
 0.27429188517743175 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Chebyshev.jl#L411-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Laguerre" href="#SpecialPolynomials.Laguerre"><code>SpecialPolynomials.Laguerre</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Laguerre{Î±, T &lt;: Number}</p><p>The  Laguerre polynomials have weight function <code>x^Î± * exp(-x)</code> over the domain <code>[0, oo)</code>. The parameter <code>Î±</code> is specified through the constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{1/2}([1,2,3])
typename(Laguerre){0.5}(1â‹…Láµ…â‚€(x) + 2â‹…Láµ…â‚(x) + 3â‹…Láµ…â‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(9.625 - 9.5*x + 1.5*x^2)</code></pre><p>The Laguerre polynomials are the case <code>Î±=0</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{0}([1,2,3])
typename(Laguerre){0}(1â‹…Lâ‚€(x) + 2â‹…Lâ‚(x) + 3â‹…Lâ‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(6.0 - 8.0*x + 1.5*x^2)

julia&gt; phi(u, i) = derivative(u) -  u # verify Rodrigues&#39; formula for small n; n! L_n = (d/dx-1)^n x^n
phi (generic function with 1 method)

julia&gt; x = Polynomial(:x)
Polynomial(1.0*x)

julia&gt; n = 7
7

julia&gt; factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)
Polynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Laguerre.jl#L4-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Hermite" href="#SpecialPolynomials.Hermite"><code>SpecialPolynomials.Hermite</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hermite</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials have two versions the physicists (<code>Hermite</code>  or  <code>H</code>) and the probablalists (<code>ChebyshevHermite</code> or  <code>Hâ‚‘</code>). They are  related through  <code>Háµ¢(x) =  2^(i/2) Hâ‚‘áµ¢(âˆš2 x)</code>.</p><p>The Hermite   polynomials have weight  function <code>w(x)=exp(-x^2/2)</code> and domain the real line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials,  SpecialPolynomials

julia&gt; x = variable(Polynomial{Rational{Int}})
Polynomial(x)

julia&gt; [basis(Hermite, i)(x) for i in 0:5]
6-element Vector{Polynomial{Float64, :x}}:
 Polynomial(1.0)
 Polynomial(2.0*x)
 Polynomial(-2.0 + 4.0*x^2)
 Polynomial(-12.0*x + 8.0*x^3)
 Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)
 Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)

julia&gt; [basis(ChebyshevHermite, i)(x) for i in 0:5]
6-element Vector{Polynomial{Float64, :x}}:
 Polynomial(1.0)
 Polynomial(1.0*x)
 Polynomial(-1.0 + 1.0*x^2)
 Polynomial(-3.0*x + 1.0*x^3)
 Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)
 Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Hermite family needs help, as the computed values for <code>Bn</code>,and,<code>Cn</code> are  both 0.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Hermite.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.ChebyshevHermite" href="#SpecialPolynomials.ChebyshevHermite"><code>SpecialPolynomials.ChebyshevHermite</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ChebyshevHermite</code></pre><p>Type for the Probabalist&#39;s  <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Hermite.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Gegenbauer" href="#SpecialPolynomials.Gegenbauer"><code>SpecialPolynomials.Gegenbauer</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Gegenbauer{Î±, T &lt;: Number}</p><p>The Gegenbauer polynomials have weight function <code>(1-x^2)^(Î±-1/2)</code> over the domain <code>[-1,1]</code>. The parameter <code>Î±</code> is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  <code>Gegenbauer{1/2}</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Gegenbauer{1/2}([1,2,3])
typename(Gegenbauer){0.5}(1â‹…Cáµ…â‚€(x) + 2â‹…Cáµ…â‚(x) + 3â‹…Cáµ…â‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.5 + 2.0*x + 4.5*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Gegenbauer.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Jacobi" href="#SpecialPolynomials.Jacobi"><code>SpecialPolynomials.Jacobi</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Jacobi{Î±,  Î², T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Jacobi_polynomials">Jacobi</a> polynomials. These have weight function <code>w(x) = (1-x)^Î± â‹… (1+x)^Î²</code> over the domain <code>[-1,1]</code>. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Jacobi{-1/2, -1/2}([0,0,1])
typename(Jacobi){-0.5,-0.5}(1â‹…Jáµ…áµâ‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.375 + 0.75*x^2)

julia&gt; monic(p) = (q=convert(Polynomial,p); q/q[end])
monic (generic function with 1 method)

julia&gt; monic(p) â‰ˆ  monic(basis(Chebyshev, 2))
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Jacobi.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.ShiftedJacobi" href="#SpecialPolynomials.ShiftedJacobi"><code>SpecialPolynomials.ShiftedJacobi</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftedJacobi{Î±,  Î², T}</code></pre><p>Implements the <a href="https://arxiv.org/abs/2004.09801">ShiftedJacobi</a> orthogonal polynomials. These have weight function <code>w(x) = (1-x)^Î± â‹… x^Î²</code> over the domain <code>[0,1]</code>. The parameters are  specified to the constructor.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; b = ShiftedJacobi{1,1}([0,0,1])
typename(ShiftedJacobi){1,1}(1â‹…Ráµ…áµâ‚‚(x))

julia&gt; convert(Polynomial, b)
Polynomial(3.0 - 15.0*x + 15.0*x^2)</code></pre><p>Note: these are not <code>Jáµ¢áµ…áµ((x+1)/2)</code>, <code>J=basis(Jacobi{Î±,Î²},i)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/ShiftedJacobi.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Bessel" href="#SpecialPolynomials.Bessel"><code>SpecialPolynomials.Bessel</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bessel{Î±}</code></pre><p>Implements the <a href="https://dlmf.nist.gov/18.34">Bessel</a> polynomials, introduced by <a href="https://www.ams.org/journals/tran/1949-065-01/S0002-9947-1949-0028473-1/S0002-9947-1949-0028473-1.pdf">Krall and Frink</a> (with <code>b=2</code>). The  case <code>a=2</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Bessel_polynomials">Bessel</a> polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitrary curve in the complex plane enclosing the  origin.  The weight  function is <code>Ï(x)=(2Ï€i)^(-1)âˆ‘Î“(Î±)/Î“(Î±+n-1)(-Î²/x)^n</code>,   where <code>Î²=2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; ğ = Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{ğ})
Polynomial(x)

julia&gt; [basis(Bessel{3//2, ğ}, i)(x) for i in 0:5]
6-element Vector{Polynomial{Rational{Int64}, :x}}:
 Polynomial(1//1)
 Polynomial(1//1 + 3//4*x)
 Polynomial(1//1 + 5//2*x + 35//16*x^2)
 Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)
 Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)
 Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Bessel.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.ShiftedLegendre" href="#SpecialPolynomials.ShiftedLegendre"><code>SpecialPolynomials.ShiftedLegendre</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ShiftedLegendre</code></pre><p>Type for the shifted Legendre polynomials: <code>PË¢áµ¢(x) =  Páµ¢(2x-1)</code> for <code>x âˆˆ [0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Legendre.jl#L118-L122">source</a></section></article><h3 id="Classical-discrete-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-discrete-orthogonal-polynomials">Classical discrete orthogonal polynomials</a><a id="Classical-discrete-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-discrete-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical discrete  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Charlier" href="#SpecialPolynomials.Charlier"><code>SpecialPolynomials.Charlier</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Charlier{Î¼}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw Â§1.12</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/Charlier.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Krawchouk" href="#SpecialPolynomials.Krawchouk"><code>SpecialPolynomials.Krawchouk</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs"> Krawchouk{p,ğ}</code></pre><p>Also spelled  Krawtchouk,  Kravhcuk,â€¦.</p><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw Â§1.10</a>;  see  also  <a href="https://arxiv.org/pdf/1101.1798.pdf">Coleman</a> for a different  parameterization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/Krawchouk.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Meixner" href="#SpecialPolynomials.Meixner"><code>SpecialPolynomials.Meixner</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Meixner{Î³,Î¼}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw Â§1.9</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/Meixner.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Hahn" href="#SpecialPolynomials.Hahn"><code>SpecialPolynomials.Hahn</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hahn{Î±,Î²,ğ}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw Â§1.5</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In  <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/Hahn.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.DiscreteChebyshev" href="#SpecialPolynomials.DiscreteChebyshev"><code>SpecialPolynomials.DiscreteChebyshev</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteChebyshev</code></pre><p>This uses p22 of <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a>  to define a two-parameter  family of <em>non</em> orthogonal polynomials. See  the example  in <a href="#SpecialPolynomials.DiscreteWeightFunction"><code>DiscreteWeightFunction</code></a> for implementing  the <a href="https://en.wikipedia.org/wiki/Discrete_Chebyshev_polynomials">DiscreteChebyshev</a>  polynomials  from Wikipedia.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; import SpecialPolynomials: Î”â‚“, âˆ‡â‚“

julia&gt; Î±,Î² = 1/2, 1
(0.5, 1)

julia&gt; P  = DiscreteChebyshev{Î±,Î²}
DiscreteChebyshev{0.5, 1}

julia&gt; i = 5
5

julia&gt; yáµ¢ = basis(P, i)
DiscreteChebyshev(1.0â‹…Kâ½áµ…áµâ¾â‚…(x))

julia&gt; x = variable(P)
DiscreteChebyshev(- 2.0â‹…Kâ½áµ…áµâ¾â‚€(x) + 2.0â‹…Kâ½áµ…áµâ¾â‚(x))

julia&gt; a,b,c,d,e = SpecialPolynomials.abcde(P)
(a = 0, b = 0, c = 1, d = 0.5, e = 1)

julia&gt; Î»áµ¢  = -(a*i*(i-1)  + d*i)
-2.5

julia&gt; Î”â‚“(âˆ‡â‚“(yáµ¢)) +  (Î±*x + Î²) * Î”â‚“(yáµ¢) â‰ˆ -Î»áµ¢*yáµ¢ # p22: &quot;are not orthogonal, but satisfy the difference equation...&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/DiscreteChebyshev.jl#L4-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.FallingFactorial" href="#SpecialPolynomials.FallingFactorial"><code>SpecialPolynomials.FallingFactorial</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FallingFactorial{T}</code></pre><p>Construct  a  polynomial with   respect to the basis <code>xâ°Ì²,  xÂ¹Ì², xÂ²Ì², â€¦</code> where <code>xâ±Ì² = x  â‹…  (x-1) â‹…  (x-2)  â‹¯ (x-i+1)</code> is the falling Pochhammer  symbol.  See <a href="https://en.wikipedia.org/wiki/Falling_and_rising_factorials">Falling factorial</a>  for several  facts about this  polynomial basis.</p><p>In <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a> connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(FallingFactorial, 3)
FallingFactorial(1.0â‹…xÂ³Ì²)

julia&gt; x = variable(Polynomial)
Polynomial(1.0*x)

julia&gt; p(x) â‰ˆ x*(x-1)*(x-2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/FallingFactorial.jl#L2-L29">source</a></section></article><hr/><p>Some non-exported methods are available or define each of  the classical orthogonal polynomials:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.weight_function" href="#SpecialPolynomials.weight_function"><code>SpecialPolynomials.weight_function</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">weight_function(p)
weight_function(::Type{P})</code></pre><p>For an orthogonal polynomial type, a function <code>w</code> with <code>âˆ« B_n(t) B_m(t) w(t) dt = 0</code> when <code>n</code> and <code>m</code> are not equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.generating_function" href="#SpecialPolynomials.generating_function"><code>SpecialPolynomials.generating_function</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generating_function(p)
generating_function(::Type{P})</code></pre><p>The generating function is a function defined by: <code>(t,x) -&gt; sum(t^n Pn(x) for n in 0:oo)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.abcde" href="#SpecialPolynomials.abcde"><code>SpecialPolynomials.abcde</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abcde</code></pre><p>A named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (aâ‹…xÂ²+bâ‹…x+c)*Pâ‚áµ¢â‚Šâ‚‚â‚&#39;&#39; + (dâ‹…x + e) * Pâ‚áµ¢â‚Šâ‚â‚ + Î»áµ¢ Páµ¢ = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/cop.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.An" href="#SpecialPolynomials.An"><code>SpecialPolynomials.An</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">An(::Type{P},n)</code></pre><p>Orthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:</p><p><code>P_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}</code></p><p>If the polynomials are monic, this is usually parameterized as:</p><p><code>Ï€_{n+1} = (x - Î±Ìƒ_n) Ï€_n - Î²Ìƒ_n Ï€_{n-1}</code></p><p>These functions are used through recursion when evaluating the polynomials, converting to <code>Polynomial</code> format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Bn" href="#SpecialPolynomials.Bn"><code>SpecialPolynomials.Bn</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bn(::Type{P},n)
Bn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Cn" href="#SpecialPolynomials.Cn"><code>SpecialPolynomials.Cn</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cn(::Type{P},n)
Cn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.jacobi_matrix" href="#SpecialPolynomials.jacobi_matrix"><code>SpecialPolynomials.jacobi_matrix</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">jacobi_matrix(::Type{P}, n)</code></pre><p>The Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the <code>alphaáµ¢</code> values, the off diagonal entries, the square root of the  <code>betaáµ¢</code> values. This matrix has the properties that</p><ul><li>the eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.</li><li>the normalized eigenvectors have initial term proportional to the weights in a quadrature formula</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L251-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.gauss_nodes_weights" href="#SpecialPolynomials.gauss_nodes_weights"><code>SpecialPolynomials.gauss_nodes_weights</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gauss_nodes_weights(::Type{P}, n)</code></pre><p>Returns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.</p><p>When loaded, the values are computed through  the <code>FastGaussQuadrature</code> package.</p><p>For some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. &quot;A fast algorithm for the calculation of the roots of special functions.&quot; SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used.</p><p>For others the Jacobi matrix, J<em>n, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of J</em>n, the weights a scaling of the first component of the normalized eigen vectors (Î²_0 * [v[1] for v in vs])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/orthogonal.jl#L270-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.lagrange_barycentric_nodes_weights" href="#SpecialPolynomials.lagrange_barycentric_nodes_weights"><code>SpecialPolynomials.lagrange_barycentric_nodes_weights</code></a> â€” <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lagrange_barycentric_nodes_weights(::Type{&lt;:SpecialPolynomial}, n::Int)</code></pre><p>Return a collection of <code>n+1</code> nodes and <em>simplified</em> weights the given family of polynomials. There are explicit formula for <code>Chebyshev</code> and <code>Chebyshev</code>, for other classical continuous orthogonal polynomials there is a relationship between the Gauss nodes and weights and the barycentric ones that is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Interpolating/Lagrange.jl#L270-L277">source</a></section></article><h3 id="Defining-new-types"><a class="docs-heading-anchor" href="#Defining-new-types">Defining new types</a><a id="Defining-new-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-types" title="Permalink"></a></h3><p>A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  <code>abcde</code>  method are known.</p><p>Polynomial systems  can also be generated  through  an associated weight function.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.WeightFunction" href="#SpecialPolynomials.WeightFunction"><code>SpecialPolynomials.WeightFunction</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeightFunction{T}</code></pre><p>A type for orthogonal polynomials relative to some weight function. The Wheeler or modified Chebyshev algorithm (<a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Gautschi</a>, <a href="https://doi.org/10.1063/1.4822929">Press and Teukolsky</a>) is used to generate the three-term recurrence relation.</p><p>If the second order differential equation, <code>Ïƒâ‹…p&#39;&#39; + Ï„â‹…p&#39; + Î»â‹…p=-</code> is known, using that to define the polynomial type would be preferred, as then several additional properties follow for free.</p><p>The key computation is the modified moment, <code>âˆ«Ï€â±¼ dw</code> where <code>Ï€â±¼</code> is the <code>j</code>th basis vector for an associated <em>monic</em> system, <code>P</code>, and <code>w</code> is the weight function.  These values are registered through the <code>@register_weight_function(Type, P, w)</code> macro, as illustrated in the examples.</p><p><strong>Example.</strong></p><p>Toy example with <code>ChebyshevU</code> being derived using the  <code>Chebyshev</code> system.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 Toy SP.WeightFunction   # register a  Toy  example

julia&gt; SP.@register_weight_function Toy MonicChebyshev SP.weight_function(ChebyshevU)

julia&gt; [SP.Cn.(Toy, 1:5) SP.Cn.(MonicChebyshevU, 1:5)]
5Ã—2 Matrix{Float64}:
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25</code></pre><p>Elliptic orthogonal polynomials on  <code>[-1,1]</code>. Demo 2 of Gautschi.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; N,  Ï‰Â² = 40, 0.999
(40, 0.999)

julia&gt; w(t) = ((1-Ï‰Â²*t^2)*(1-t^2))^(-1/2)
w (generic function with 1 method)

julia&gt; SP.@register0 WF SP.WeightFunction

julia&gt; SP.@register_weight_function WF MonicChebyshev w

julia&gt; Î±s, Î²s = -SP.Bn.(WF, 0:5), SP.Cn.(WF, 0:5);

julia&gt; [Î±s Î²s]
6Ã—2 Matrix{Float64}:
 -1.87309e-15  9.68226
 -7.11555e-18  0.793782
 -1.76472e-15  0.119868
 -2.89401e-15  0.22704
 -4.11827e-15  0.241061
 -5.47762e-15  0.245428</code></pre><p>The main computation involved in this is the modified moment, <code>Î½â±¼ = âˆ«Ï€â±¼ dw</code>, computed with <code>QuadGK.quadgk</code>. For some examples, this computation can be completed directly and the <code>modified_moment</code> method may be overloaded for the type. This example is from Press and Teukolsky, where the modified moments are given through the function <code>v(j)</code> defined below.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials, SpecialFunctions

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; w(t) = -log(t)
w (generic function with 1 method)

julia&gt; SP.@register0 WF1 SP.WeightFunction   #  register  type WF1 as a weight function

julia&gt; SP.@register_weight_function WF1  MonicShiftedLegendre w

julia&gt; Î½(j) = iszero(j) ? 1 : (-1)^j * gamma(j+1)^2 / (j*(j+1)*gamma(2j+1)) # help  out
Î½ (generic function with 1 method)

julia&gt; SP.modified_moment(::Type{WF1},  j::Int) = Î½(j)

julia&gt; Î±s, Î²s = -SP.Bn.(WF1, 0:5), SP.Cn.(WF1, 0:5);

julia&gt; [Î±s Î²s]
6Ã—2 Matrix{Float64}:
 -0.75      1.0
 -0.381148  0.423611
 -0.504058  0.172646
 -0.516236  0.203166
 -0.517168  0.222419
 -0.513854  0.239667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/WeightFunction.jl#L11-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.DiscreteWeightFunction" href="#SpecialPolynomials.DiscreteWeightFunction"><code>SpecialPolynomials.DiscreteWeightFunction</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DiscreteWeightFunction</code></pre><p>For a discrete measure, <code>dÎ» = âˆ‘ wáµ¢ Î´(x - xáµ¢)</code>, specified through two vectors, <code>xs</code> and <code>ws</code>, a collection of monic orthogonal polynomials is produced through Darboux&#39;s formula for <code>Î±_n</code> and <code>Î²_n</code> using the 3-term recurrence defined by <code>Ï€_{n+1} = (x-Î±_n)â‹…Ï€_n - Î²_nâ‹…Ï€_{n-1}</code> (<code>An=1</code>, <code>Bn=-Î±_n</code>, <code>Cn=Î²_n</code>) and the discrete Stieltjes method <a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Guatschi Â§3.1</a>.</p><p><strong>Example</strong></p><p>Discrete Chebyshev by its weight function (uniform  on 0,1,â€¦,N-1)</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials;

julia&gt; N = 9
9

julia&gt; xs, ws = collect(0:N-1), ones(N);   # w(x) = âˆ‘ wâ±¼â‹…Î´(x-xâ±¼)

julia&gt; SP.@register0 DWF DiscreteWeightFunction

julia&gt; SP.@register_discrete_weight_function(DWF, xs, ws)

julia&gt; [SP.Bn.(DWF, 0:N-1) SP.Cn.(DWF, 0:N-1)]
9Ã—2 Matrix{Float64}:
 -4.0  9.0
 -4.0  6.66667
 -4.0  5.13333
 -4.0  4.62857
 -4.0  4.12698
 -4.0  3.53535
 -4.0  2.83217
 -4.0  2.01026
 -4.0  1.06667

julia&gt; i,j = 3,4; ## check  that âˆ«páµ¢pâ±¼dw  = 0    for i,j=3,4

julia&gt; sum(basis(DWF,i)(x) *  basis(DWF,j)(x) * w for  (x,w) in zip(xs, ws))
5.684341886080802e-14

julia&gt; ## Gogin, Hirvensalo (https://doi.org/10.1007/s10958-017-3410-8) characterization
       D(k,N,x) =  sum((-1)^l * binomial(k+l,k) * binomial(N-l,k-l) *  SP.generalized_binomial(x,l) for l in 0:k)
D (generic function with 1 method)

julia&gt; x = variable()
Polynomial(x)</code></pre><pre><code class="nohighlight hljs"># broken. Fix me.
julia&gt; ps,qs = [D(k,N-1,x)  for  k in 0:N-1], [basis(DWF, k)(x) for k  in 0:N-1];

julia&gt; all(qs .* [p[end] for p  in ps] .â‰ˆ ps)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Orthogonal/Discrete/discrete-orthogonal.jl#L25-L84">source</a></section></article><h3 id="Interpolating-polynomials"><a class="docs-heading-anchor" href="#Interpolating-polynomials">Interpolating polynomials</a><a id="Interpolating-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.AbstractInterpolatingPolynomial" href="#SpecialPolynomials.AbstractInterpolatingPolynomial"><code>SpecialPolynomials.AbstractInterpolatingPolynomial</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractInterpolatingPolynomial{T,X}</code></pre><p>Abstract type for interpolating polynomials.</p><p>These are polynomial representations of <code>p(x)</code> satisfying <code>p(x_i) = y_i</code> for a specified set of <code>x</code> values and <code>y</code> values.</p><p>For a collection of points <code>(x_0,y_0), ..., (x_n, y_n)</code> there is a <em>unique</em> polynomial of degree <code>n</code> or less satisfying <code>p(x_i)=y_i</code>. This fact allows the specification of <code>p(x)</code> using a vector of coefficients relative to some set of basis vectors.</p><p>The two main types, <code>Lagrange</code> and <code>Newton</code>, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like <code>convert(::Type, p)</code> will not work. Use <code>fit(Type, xs, p)</code>, as appropriate, instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Interpolating/interpolating.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Lagrange" href="#SpecialPolynomials.Lagrange"><code>SpecialPolynomials.Lagrange</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Lagrange(xs, [ws], coeffs, [var])</code></pre><p>Lagrange interpolation of points <code>(xáµ¢, fáµ¢)</code> for <code>i âˆˆ 0..n</code>.</p><ul><li><code>xs</code>, <code>coeffs</code>: the interpolating coordinates.</li><li><code>ws</code>: weights used in the barycentric representation. (From <code>SpecialPolynomials.lagrange_barycentric_weights</code> or <code>SpecialPolynomials.lagrange_barycentric_nodes_weights</code>.)</li><li>var: the polynomial indeterminate</li></ul><p><strong>Extended help</strong></p><p>The Lagrange interpolation of points <code>(xáµ¢, fáµ¢)</code> for <code>i âˆˆ 0:n</code> is the polynomial <code>p(x) = âˆ‘áµ¢ lâ±¼(x) fâ±¼</code>.</p><p>The basis vectors <code>lâ±¼(x)</code> are <code>1</code> on <code>xâ±¼</code> and <code>0</code> on <code>xáµ¢</code> when <code>i â‰  j</code>. That is, <code>lâ±¼(x) = Î _{i â‰  j}(x-xáµ¢)/Î _{i â‰ j}(xâ±¼-xáµ¢)</code>. These can be rewritten in terms of weights, <code>wâ±¼</code>, depending on the <code>xáµ¢</code> only, yielding <code>lâ±¼ = l(x) wâ±¼/(x - xâ±¼)</code> with <code>l(x) = Î (x-xáµ¢)</code>. Going further, yields the barycentric formula:</p><p><code>p(x) = (âˆ‘ wâ±¼ / (x - xâ±¼) â‹… fâ±¼) /  (âˆ‘ wâ±¼ / (x - xâ±¼) )</code>.</p><p>This representation has several properties, as detailed in Berrut and Trefethen <a href="https://doi.org/10.1137/S0036144502417715">Barycentric Lagrange Interpolation</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))

julia&gt; p.([1,2,3]) # the coefficients
3-element Vector{Int64}:
 1
 2
 3

julia&gt; convert(Polynomial,  p)
Polynomial(1.0*x)</code></pre><p>The instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as <code>variable</code> or <code>convert(Lagrange, ...)</code>. For the former we can use an instance, for the latter we can use <code>fit</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))

julia&gt; variable(p)
Lagrange(1â‹…â„“_0(x) + 2â‹…â„“_1(x) + 3â‹…â„“_2(x))

julia&gt; q = Polynomial([0,0,1])
Polynomial(x^2)

julia&gt; qq = fit(Lagrange, p.xs, p.ws, q)
Lagrange(1â‹…â„“_0(x) + 4â‹…â„“_1(x) + 9â‹…â„“_2(x))

julia&gt; convert(Polynomial, qq)
Polynomial(1.0*x^2)</code></pre><p>For a given set of nodes, <code>SpecialPolynomials.lagrange_barycentric_weights</code> can compute the weights.  For all but modest values of <code>n</code>, interpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. (They should have asymptotic density of <code>1/âˆš(1-x^2)</code> over <code>[-1,1]</code>.) For <code>P=Chebyshvev</code> and <code>P=ChebyshevU</code>, the function <code>SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n)</code> will return a good choice of <code>n+1</code> points over <code>[-1,1]</code> along with precomputed weights.</p><pre><code class="language-julia-repl hljs">julia&gt; xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(Chebyshev, 64);


julia&gt; f(x) = exp(-x)*sinpi(x)
f (generic function with 1 method)

julia&gt; p = fit(Lagrange, xs, f.(xs));


julia&gt; degree(p)
64

julia&gt; maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) &lt;= 1e-14
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above example is more directly done through <code>fit(Chebyshev, f, 64)</code>, though the resulting polynomial will reference a different basis.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Interpolating/Lagrange.jl#L1-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Newton" href="#SpecialPolynomials.Newton"><code>SpecialPolynomials.Newton</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Newton{N,S,T,X}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Newton_polynomial">Newton</a> interpolating polynomial uses a basis <code>1</code>, <code>(x-x_0)</code>, <code>(x-x_0)(x-x_1)</code>, ..., <code>(x-x0)(x-x1)â‹…â‹…â‹…(x-x_{n-1})</code> and coefficients (in forward form) <code>f[x_0]</code>, <code>f[x_0,x_1]</code>, ...,<code>f[x_0,...,x_n]</code>. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.</p><p>The easiest way to construct an instance is with <code>fit</code>, as in:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;

julia&gt; p = fit(Newton, xs, f)
Newton(5.0â‹…p_1(x) + 6.0â‹…p_2(x) + 1.0â‹…p_3(x))

julia&gt; p.(xs) == f.(xs)  # p interpolates
true

julia&gt; convert(Polynomial, p)
Polynomial(1.0 - 2.0*x + 1.0*x^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Interpolating/Newton.jl#L1-L28">source</a></section></article><h3 id="Other-polynomials"><a class="docs-heading-anchor" href="#Other-polynomials">Other polynomials</a><a id="Other-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Other-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.Bernstein" href="#SpecialPolynomials.Bernstein"><code>SpecialPolynomials.Bernstein</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Bernstein{N, T, X}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Bernstein_polynomial">Bernstein  polynomial</a> is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, <code>ğ</code>, this is a set of <code>ğ+1</code> degree <code>ğ</code> polynomials of the form: <code>Î²_{ğ,Î½} =  (Î½ choose ğ) x^Î½  (1-x)^{ğ-Î½}</code>, <code>0 â‰¤ x â‰¤ 1.</code></p><p>The <code>Bernstein{ğ,T}</code> type represents a polynomial of degree <code>ğ</code> or less with a linear combination of the basis vectors using coefficients of type <code>T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(Bernstein{3},  2)
Bernstein(1â‹…Î²â‚ƒ,â‚‚(x))

julia&gt; convert(Polynomial, p)
Polynomial(3.0*x^2 - 3.0*x^3)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="https://github.com/tkoolen/StaticUnivariatePolynomials.jl">StaticUnivariatePolynomials</a> offers a  more  performant version.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/Bernstein.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SpecialPolynomials.DualBernstein" href="#SpecialPolynomials.DualBernstein"><code>SpecialPolynomials.DualBernstein</code></a> â€” <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DualBernstein{N, Î±, Î², T, X}</code></pre><p>Given the inner product <code>&lt;f,g&gt; = âˆ«â‚€Â¹ (1-x)áµ… xáµ f(x) g(x) dx</code> and the Bernstein polynomials <code>Báµ¢â¿(x)</code> the dual Bernstein polynomials satisfy <code>&lt;Báµ¢â¿, Dâ±¼â¿(x;Î±,Î²)&gt; = Î´áµ¢â±¼</code></p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; n,Î±,Î² = 5, 0, 0;

julia&gt; D = DualBernstein{n,Î±,Î²}
DualBernstein{5, 0, 0}

julia&gt; bi = basis(D, 3)
DualBernstein(1.0â‹…Î²áµ…áµâ‚…,â‚ƒ(x))

julia&gt; bi(0.2)
7.910400000000036</code></pre><p>The Bernstein-Bezier form of <code>f</code> minimizes the value of the least-square error for the <code>Î±-Î²</code> norm.</p><pre><code class="language-julia hljs">julia&gt; function ip(f,g,Î±,Î²; n=100) # compute &lt;&gt;áµ…áµ inner product
           simpsons  = (f,a,b) -&gt; (c = a/2 + b/2;(1/6) * (f(a) + 4*f(c) + f(b)))
           Î» = x -&gt; (1-x)^Î±*x^Î² * f(x) * g(x)
           xs = range(0, 1, n+1)
           xsâ€² = zip(Iterators.take(xs, n), Iterators.drop(xs, 1))
           sum(simpsons(Î», xáµ¢â‚‹â‚, xáµ¢) * (xáµ¢-xáµ¢â‚‹â‚) for (xáµ¢â‚‹â‚, xáµ¢) âˆˆ xsâ€²)
       end;

julia&gt; f(x) = sin(x);

julia&gt; n, Î±, Î² = 5, 1/2, 1/2
(5, 0.5, 0.5)

julia&gt; B, D = Bernstein{n}, DualBernstein{n,Î±,Î²};

julia&gt; Iâ‚– = [ip(f, basis(D,k), Î±, Î²) for k in 0:n];

julia&gt; pâ‚™ = B(Iâ‚–);

julia&gt; Î» = x -&gt; f(x) - pâ‚™(x);

julia&gt; ip(Î»,Î», Î±, Î²)
0.023445701885079478</code></pre><p><strong>Reference</strong></p><p>The implementation follows that of <a href="https://arxiv.org/abs/2004.09801">Chudy and WoÅºny</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/a109f7aece9c8c5c1318203188b35dfe3a06a7c8/src/DualBernstein.jl#L1-L53">source</a></section></article><h4 id="Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-á´º-báµ¢Báµ¢(t)):"><a class="docs-heading-anchor" href="#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-á´º-báµ¢Báµ¢(t)):">Example of a <a href="https://pomax.github.io/bezierinfo/">Bezier</a> curve (parameterized by <code>r(t) = âˆ‘â‚€á´º báµ¢Báµ¢(t)</code>):</a><a id="Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-á´º-báµ¢Báµ¢(t)):-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-á´º-báµ¢Báµ¢(t)):" title="Permalink"></a></h4><pre><code class="language-julia hljs">bs = [[220, 260], [220, 40], [35, 100],  [120, 140]]

p = Bernstein(bs)
ts = range(0, stop=1, length=50)
ps = p.(ts)
xs, ys = [[páµ¢[1] for páµ¢ âˆˆ ps], [páµ¢[2] for páµ¢ âˆˆ ps]]
p = plot(xs, ys, legend=false)
scatter!(p, [b[1] for b in bs], [b[2] for b in bs])</code></pre><p><img src="bezier.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Friday 28 March 2025 17:01">Friday 28 March 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
