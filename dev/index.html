<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SpecialPolynomials.jl · SpecialPolynomials</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SpecialPolynomials</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>SpecialPolynomials.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Orthogonal-polynomials"><span>Orthogonal polynomials</span></a></li><li><a class="tocitem" href="#Implemented-polynomial-types"><span>Implemented polynomial  types</span></a></li></ul></li><li><a class="tocitem" href="examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpecialPolynomials.jl"><a class="docs-heading-anchor" href="#SpecialPolynomials.jl">SpecialPolynomials.jl</a><a id="SpecialPolynomials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SpecialPolynomials.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jverzani/SpecialPolynomials.jl">SpecialPolynomials.jl</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This package provides a number of different polynomial types to represent polynomials, extending the <code>Polynomials</code> package.</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractSpecialPolynomial" href="#SpecialPolynomials.AbstractSpecialPolynomial"><code>SpecialPolynomials.AbstractSpecialPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractSpecialPolynomial{T,X}</code></pre><p>An abstract type to distinguish the different polynomial types in this package.</p><p>The concrete types specify different bases for the space of polynomials of degree <code>n</code> or less.</p><p>This package includes:</p><ul><li>several classic orthogonal polynomials.</li><li>Newton and Lagrange interpolating polynomials</li><li>Bernstein polynomials</li></ul><p>As many of the methods for the base <code>Polynomials</code> class are directly coded if possible, but quite a few depend on conversion to the base <code>Polynomial</code> type (which uses the standard polynomial basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/abstract.jl#L1-L17">source</a></section></article><h2 id="Orthogonal-polynomials"><a class="docs-heading-anchor" href="#Orthogonal-polynomials">Orthogonal polynomials</a><a id="Orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractOrthogonalPolynomial" href="#SpecialPolynomials.AbstractOrthogonalPolynomial"><code>SpecialPolynomials.AbstractOrthogonalPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOrthogonalPolynomial{T,X}</code></pre><p>Type to represent systems of orthogonal polynomials. These polynomials have  several properties, including an accompanying inner product satsifying  <code>⟨yᵢ, yⱼ⟩ = cᵢδᵢⱼ</code>.</p><p>In addition to methods inherited from the underlying <code>AbstractPolynomial</code>  type, orthogonal polynomial  types may have methods   <code>weight_function</code>, <code>generating_function</code>, <code>leading_term</code>, <code>norm2</code>, <code>jacobi_matrix</code>, and <code>gauss_nodes_weights</code>,  though none are  exported.</p><p>Subtypes of <code>AbstractCOP &lt;: AbstractOrthogonalPolynomial</code> utilize the fact that the basis  polynomials  satisfy</p><p><code>(ax² + bx + c)yᵢ&#39;&#39;(x) + (dx+e)yᵢ&#39;(x) + λᵢyᵢ(x) = 0</code> (or a discrete analogue)</p><p>where the structural relations are functions of <code>a,b,c,d,e</code>. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the <code>Polynomial</code> type (the <code>FallingFactorial</code> type in the discrete  c case),</p><p>A key structural relation is the three-term recursion,  <code>yᵢ₊₁ =  (Aᵢx +  Bᵢ)yᵢ -  Cᵢyᵢ₋₁</code>. For systems  specfied by  a  weight function, the  values of <code>Aᵢ</code>, <code>Bᵢ</code>, and <code>Cᵢ</code> can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the <code>Polynomial</code>  type throughe evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractCCOP" href="#SpecialPolynomials.AbstractCCOP"><code>SpecialPolynomials.AbstractCCOP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCCOP{T,X} &lt;:  AbstractCOP{T,X}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a>, a family <code>y(x)=p_n(x)=k_x⋅x^n +  ...</code> for  <code>n  ∈  {0, 1,…}, k_n ≠ 0</code> of polynomials is a family of classic <em>continuous</em> orthogonal polynomials if each is  a solution of the differential equation</p><p><code>(a⋅x²+b⋅x+c) ⋅ yᵢ&#39;&#39; + (d⋅x + e) ⋅ yᵢ&#39; + λᵢ⋅ yᵢ = 0.</code></p><p>A family is characterized, up to choice of leading term, by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>σ = (a⋅x²+b⋅x+c)</code>, <code>τ = (d⋅x + e)</code>.</p><p>From these  5  coefficients several structural  equations are represented. For example the three-point recusion.</p><p><code>P₍ᵢ₊₁₎ = (Aᵢ⋅x + Bᵢ) * Pᵢ - Cᵢ *  P₍ᵢ₋₁₎</code>,</p><p>where <code>Aᵢ,Bᵢ,Cᵢ</code> can be represented in formulas involving just  <code>a,b,c,d,e</code> and <code>i</code>.</p><p>Rearranging   gives the structural equation:</p><p><code>x⋅p_n   = [an, bn, cn] ⋅ [p_{n+1}, p_n, p_{n-1}]</code>  (Eqn (7))</p><p>The other structural equations are (equation  references are from Koepf and Schmersau):</p><p><code>σ⋅p&#39;_n  = [αn, βn, γn] ⋅  [p_{n+1}, p_n, p_{n-1}]</code> (Eqn (9), n ≥ 1)</p><p><code>p_n = [ân, b̂n, ĉn]  ⋅  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn (19))</p><p><code>x⋅p&#39;_n  = [αᴵn, βᴵn, γᴵn] ⋅  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn  (14))</p><p>Using (7), Clenshaw polynomial evaluation using the three  point recursion is defined.</p><p>Using (19), expressions for derivatives are found.</p><p>Using  (19), expressions for integration are found (p7).</p><p>Using their theorems 2,4, and 5, connection coefficients, <code>C(n,m)</code> satisfying <code>P_n(x) =  ∑  C(n,m)  Q_m(x) (n ≥ 0, 0 ≤  m ≤ n)</code> are  found. These allow  fallback  definitions for <code>convert(Polynomial,p)</code>,  <code>convert(P, p::Polynomial)</code>, <code>convert(P{α…}, p::P(β…))</code> and through composition polynomial  multiplication,  <code>p*q</code>.</p><p>Subtypes of <code>AbstractCCOP</code> are  created through  the <code>@register0</code> or  <code>@registerN</code> macros, where the  <code>N</code>  macro  is used  if parameters are  needed to describe the family.</p><p>If non-monic versions are desired, then the  leading  term can be  specified through <code>kn()</code> (which by default is defined by the  method <code>k1k0(P,i)</code>, the ratio of  <code>kᵢ₊₁/kᵢ</code>).  The <code>@register_monic</code> macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the <code>@register_shifted</code> macro is useful  to provide shifted versions (cf. <a href="#SpecialPolynomials.ShiftedLegendre"><code>ShiftedLegendre</code></a>).</p><p>Registering a system, defining an <code>abcde</code> method, and optionally defining <code>k1k0</code> is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.</p><p>The defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. <code>Chebyshev</code>,<code>ChebyshevU</code>, <code>Hermite</code>, <code>Laguerre</code>), but not all.</p><p><strong>Example</strong></p><p>For this example, the value of <code>Bn</code> at <code>0</code> needs help:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 MonicLegendre′ SP.AbstractCCOP0

julia&gt; SP.:ϟ(::Type{&lt;:MonicLegendre′}) = Legendre

julia&gt; SP.@register_monic MonicLegendre′  # use  ϟ to delegate methods

julia&gt; 𝐐  =  Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{𝐐})
Polynomials.Polynomial(x)

julia&gt; [basis(MonicLegendre′{𝐐}, i)(x) for i  in 0:5]
6-element Vector{Polynomial{T, :x} where T}:
 Polynomials.Polynomial(1//1)
 Polynomials.Polynomial(1.0*x)
 Polynomials.Polynomial(-0.3333333333333333 + 1.0*x^2)
 Polynomials.Polynomial(-0.6*x + 1.0*x^3)
 Polynomials.Polynomial(0.0857142857142857 - 0.857142857142857*x^2 + 1.0*x^4)
 Polynomials.Polynomial(0.23809523809523805*x - 1.111111111111111*x^3 + 1.0*x^5)</code></pre><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/ccop.jl#L6-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractCDOP" href="#SpecialPolynomials.AbstractCDOP"><code>SpecialPolynomials.AbstractCDOP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> AbstractCDOP{T,X} &lt;: AbstractCOP{T,X}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf  and Schmersau</a>, a family <code>y(x)=p_n(x)=k_x⋅x^n +  ...</code> for  <code>n  ∈  {0, 1,…}, k_n ≠ 0</code> of polynomials is a family of classic <em>discrete</em> orthogonal polynomials if it  is  a solution of a differential equation</p><p><code>(a⋅x²+b⋅x+c) ⋅ Δ∇y + (d⋅x + e) ⋅ ∇&#39; + λᵢ⋅ y = 0</code>,</p><p>where  <code>Δy(x) = y(x+1) - y(x)</code> and <code>∇y(x) = y(x) - y(x-1)</code>.</p><p>A family is characterized by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>σ = (a⋅x²+b⋅x+c)</code>, <code>τ = (d⋅x + e).</code></p><p>As in the classical-continuous-orthogonal-polynomial case <a href="#SpecialPolynomials.AbstractCCOP"><code>AbstractCCOP</code></a>, from these 5 values the cofficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.</p><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials.</p><p>For example, on p29 they give  formulas for Hahn polynomials through:</p><p><code>n(n+α+β+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1)</code>,  with  explicit values  for  <code>B</code> and <code>D</code>. Reexpressing gives: <code>BΔy(x) - D∇y(x) -λ y(x)  = 0</code>. From the rexpressed Eqn (4) for Koepf &amp; Schemersau we have the identification: <code>σ+τ =  B; σ=D</code>,  so  <code>τ=B-D</code>. From this <code>a,b,c,d,e</code> can be  gleaned.</p><p>The above, is termed the eigevalue equation (e.g. <a href="https://arxiv.org/pdf/1609.07291.pdf">Goertz and Offner</a>), as it can be reexpressed as</p><p><code>Δ(D(x)⋅ω(x)⋅∇yᵢ(x) = λᵢ⋅ω(x)⋅yᵢ(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/cdop.jl#L4-L41">source</a></section></article><h2 id="Implemented-polynomial-types"><a class="docs-heading-anchor" href="#Implemented-polynomial-types">Implemented polynomial  types</a><a id="Implemented-polynomial-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-polynomial-types" title="Permalink"></a></h2><h3 id="Classical-continuous-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-continuous-orthogonal-polynomials">Classical continuous orthogonal polynomials</a><a id="Classical-continuous-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-continuous-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical continuous  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Legendre" href="#SpecialPolynomials.Legendre"><code>SpecialPolynomials.Legendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Legendre{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre</a> polynomials. These have weight function <code>w(x) = 1</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Legendre([1,2,3])
Legendre(1⋅P₀(x) + 2⋅P₁(x) + 3⋅P₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(-0.5 + 2.0*x + 4.5*x^2)

julia&gt; p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k
(Legendre(1.0⋅P₈(x)), Legendre(1.0⋅P₉(x)))

julia&gt; p2m(-1) == 1
false

julia&gt; p2m1(-1) == -1
false

julia&gt; n = 5  # verify  Rodrigues&#39; formula 
5

julia&gt; x = Polynomial(:x)
Polynomials.Polynomial(1.0*x)

julia&gt; derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)
Polynomials.Polynomial(0.0)

julia&gt; p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  P₄,P₅
(Legendre(1.0⋅P₄(x)), Legendre(1.0⋅P₅(x)))

julia&gt; SpecialPolynomials.innerproduct(Legendre, p4,  p5)
-1.5309832087675112e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Legendre.jl#L9-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Chebyshev" href="#SpecialPolynomials.Chebyshev"><code>SpecialPolynomials.Chebyshev</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Chebyshev{&lt;:Number}(coeffs::AbstractVector, var=:x)</code></pre><p>Chebyshev polynomial of the first kind.</p><p>Construct a polynomial from its coefficients <code>a</code>, lowest order first, optionally in terms of the given variable <code>x</code>. <code>x</code> can be a character, symbol, or string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; Chebyshev([1, 0, 3, 4])
Chebyshev(1⋅T₀(x) + 3⋅T₂(x) + 4⋅T₃(x))

julia&gt; Chebyshev([1, 2, 3, 0], :s)
Chebyshev(1⋅T₀(s) + 2⋅T₁(s) + 3⋅T₂(s))

julia&gt; one(Chebyshev)
Chebyshev(1.0⋅T₀(x))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is copied from the <code>ChebyshevT</code> example from the <code>Polynomials</code> package by Miles Lucas.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The sample chapter available online of <a href="https://archive.siam.org/books/ot99/OT99SampleChapter.pdf">Numerical Methods for Special Functions&quot; by Amparo Gil, Javier Segura, and Nico Temme</a> gives a very nice overview of these polynomials.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Chebyshev.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ChebyshevU" href="#SpecialPolynomials.ChebyshevU"><code>SpecialPolynomials.ChebyshevU</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChebyshevU{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev</a> polynomials of the second kind. These have weight function <code>w(x) = sqrt(1-x^2)</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = ChebyshevU([1,2,3])
ChebyshevU(1⋅U₀(x) + 2⋅U₁(x) + 3⋅U₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(-2.0 + 4.0*x + 12.0*x^2)

julia&gt; derivative(p)
ChebyshevU(4.0⋅U₀(x) + 12.0⋅U₁(x))

julia&gt; roots(p)
2-element Vector{ComplexF64}:
 -0.6076252185107651 + 0.0im
 0.27429188517743175 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Chebyshev.jl#L412-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Laguerre" href="#SpecialPolynomials.Laguerre"><code>SpecialPolynomials.Laguerre</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Laguerre{α, T &lt;: Number}</p><p>The  Laguerre polynomials have weight function <code>x^α * exp(-x)</code> over the domain <code>[0, oo)</code>. The parameter <code>α</code> is specified through the constructor.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{1/2}([1,2,3])
typename(Laguerre){0.5}(1⋅Lᵅ₀(x) + 2⋅Lᵅ₁(x) + 3⋅Lᵅ₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(9.625 - 9.5*x + 1.5*x^2)</code></pre><p>The Laguerre polynomials are the case <code>α=0</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{0}([1,2,3])
typename(Laguerre){0}(1⋅L₀(x) + 2⋅L₁(x) + 3⋅L₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(6.0 - 8.0*x + 1.5*x^2)

julia&gt; phi(u, i) = derivative(u) -  u # verify Rodrigues&#39; formula for small n; n! L_n = (d/dx-1)^n x^n
phi (generic function with 1 method)

julia&gt; x = Polynomial(:x)
Polynomials.Polynomial(1.0*x)

julia&gt; n = 7
7

julia&gt; factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)
Polynomials.Polynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Laguerre.jl#L4-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Hermite" href="#SpecialPolynomials.Hermite"><code>SpecialPolynomials.Hermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hermite</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials have two versions the physicists (<code>Hermite</code>  or  <code>H</code>) and the probablalists (<code>ChebyshevHermite</code> or  <code>Hₑ</code>). They are  related through  <code>Hᵢ(x) =  2^(i/2) Hₑᵢ(√2 x)</code>.</p><p>The Hermite   polynomials have weight  function <code>w(x)=exp(-x^2/2)</code> and domain the real line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials,  SpecialPolynomials

julia&gt; x = variable(Polynomial{Rational{Int}})
Polynomials.Polynomial(x)

julia&gt; [basis(Hermite, i)(x) for i in 0:5]
6-element Vector{Polynomial{Float64, :x}}:
 Polynomials.Polynomial(1.0)
 Polynomials.Polynomial(2.0*x)
 Polynomials.Polynomial(-2.0 + 4.0*x^2)
 Polynomials.Polynomial(-12.0*x + 8.0*x^3)
 Polynomials.Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)
 Polynomials.Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)

julia&gt; [basis(ChebyshevHermite, i)(x) for i in 0:5]
6-element Vector{Polynomial{Float64, :x}}:
 Polynomials.Polynomial(1.0)
 Polynomials.Polynomial(1.0*x)
 Polynomials.Polynomial(-1.0 + 1.0*x^2)
 Polynomials.Polynomial(-3.0*x + 1.0*x^3)
 Polynomials.Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)
 Polynomials.Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Hermite family needs help, as the computed values for <code>Bn</code>,and,<code>Cn</code> are  both 0.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Hermite.jl#L5-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ChebyshevHermite" href="#SpecialPolynomials.ChebyshevHermite"><code>SpecialPolynomials.ChebyshevHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChebyshevHermite</code></pre><p>Type for the Probabalist&#39;s  <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Hermite.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Gegenbauer" href="#SpecialPolynomials.Gegenbauer"><code>SpecialPolynomials.Gegenbauer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Gegenbauer{α, T &lt;: Number}</p><p>The Gegenbauer polynomials have weight function <code>(1-x^2)^(α-1/2)</code> over the domain <code>[-1,1]</code>. The parameter <code>α</code> is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  <code>Gegenbauer{1/2}</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Gegenbauer{1/2}([1,2,3])
typename(Gegenbauer){0.5}(1⋅Cᵅ₀(x) + 2⋅Cᵅ₁(x) + 3⋅Cᵅ₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(-0.5 + 2.0*x + 4.5*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Gegenbauer.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Jacobi" href="#SpecialPolynomials.Jacobi"><code>SpecialPolynomials.Jacobi</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Jacobi{α,  β, T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Jacobi_polynomials">Jacobi</a> polynomials. These have weight function <code>w(x) = (1-x)^α ⋅ (1+x)^β</code> over the domain <code>[-1,1]</code>. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Jacobi{-1/2, -1/2}([0,0,1])
typename(Jacobi){-0.5,-0.5}(1⋅Jᵅᵝ₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(-0.375 + 0.75*x^2)

julia&gt; monic(p) = (q=convert(Polynomial,p); q/q[end])
monic (generic function with 1 method)

julia&gt; monic(p) ≈  monic(basis(Chebyshev, 2))
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Jacobi.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bessel" href="#SpecialPolynomials.Bessel"><code>SpecialPolynomials.Bessel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bessel{α}</code></pre><p>Implements the <a href="https://dlmf.nist.gov/18.34">Bessel</a> polynomials, introduced by <a href="https://www.ams.org/journals/tran/1949-065-01/S0002-9947-1949-0028473-1/S0002-9947-1949-0028473-1.pdf">Krall and Frink</a> (with <code>b=2</code>). The  case <code>a=2</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Bessel_polynomials">Bessel</a> polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitray curve in the complex plane enclosing the  origin.  The weight  function is <code>ρ(x)=(2πi)^(-1)∑Γ(α)/Γ(α+n-1)(-β/x)^n</code>,   where <code>β=2</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; 𝐐 = Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{𝐐})
Polynomials.Polynomial(x)

julia&gt; [basis(Bessel{3//2, 𝐐}, i)(x) for i in 0:5]
6-element Vector{Polynomial{Rational{Int64}, :x}}:
 Polynomials.Polynomial(1//1)
 Polynomials.Polynomial(1//1 + 3//4*x)
 Polynomials.Polynomial(1//1 + 5//2*x + 35//16*x^2)
 Polynomials.Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)
 Polynomials.Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)
 Polynomials.Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Bessel.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ShiftedLegendre" href="#SpecialPolynomials.ShiftedLegendre"><code>SpecialPolynomials.ShiftedLegendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftedLegendre</code></pre><p>Type for the shifted Legendre polynomials: <code>Pˢᵢ(x) =  Pᵢ(2x-1)</code> for <code>x ∈ [0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Legendre.jl#L124-L128">source</a></section></article><h3 id="Classical-discrete-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-discrete-orthogonal-polynomials">Classical discrete orthogonal polynomials</a><a id="Classical-discrete-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-discrete-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical discrete  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Charlier" href="#SpecialPolynomials.Charlier"><code>SpecialPolynomials.Charlier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Charlier{μ}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw §1.12</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/Charlier.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Krawchouk" href="#SpecialPolynomials.Krawchouk"><code>SpecialPolynomials.Krawchouk</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> Krawchouk{p,𝐍}</code></pre><p>Also spelled  Krawtchouk,  Kravhcuk,….</p><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw §1.10</a>;  see  also  <a href="https://arxiv.org/pdf/1101.1798.pdf">Coleman</a> for a different  parameterization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/Krawchouk.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Meixner" href="#SpecialPolynomials.Meixner"><code>SpecialPolynomials.Meixner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Meixner{γ,μ}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw §1.9</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/Meixner.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Hahn" href="#SpecialPolynomials.Hahn"><code>SpecialPolynomials.Hahn</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hahn{α,β,𝐍}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw §1.5</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In  <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/Hahn.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.DiscreteChebyshev" href="#SpecialPolynomials.DiscreteChebyshev"><code>SpecialPolynomials.DiscreteChebyshev</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscreteChebyshev</code></pre><p>This uses p22 of <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a>  to define a two-parameter  family of <em>non</em> orthogonal polynomials. See  the example  in <a href="#SpecialPolynomials.DiscreteWeightFunction"><code>DiscreteWeightFunction</code></a> for implementing  the <a href="https://en.wikipedia.org/wiki/Discrete_Chebyshev_polynomials">DiscreteChebyshev</a>  polynomials  from Wikipedia.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; import SpecialPolynomials: Δₓ, ∇ₓ

julia&gt; α,β = 1/2, 1
(0.5, 1)

julia&gt; P  = DiscreteChebyshev{α,β}
DiscreteChebyshev{0.5, 1}

julia&gt; i = 5
5

julia&gt; yᵢ = basis(P, i)
DiscreteChebyshev(1.0⋅K⁽ᵅᵝ⁾₅(x))

julia&gt; x = variable(P)
DiscreteChebyshev(- 2.0⋅K⁽ᵅᵝ⁾₀(x) + 2.0⋅K⁽ᵅᵝ⁾₁(x))

julia&gt; a,b,c,d,e = SpecialPolynomials.abcde(P)
(a = 0, b = 0, c = 1, d = 0.5, e = 1)

julia&gt; λᵢ  = -(a*i*(i-1)  + d*i)
-2.5

julia&gt; Δₓ(∇ₓ(yᵢ)) +  (α*x + β) * Δₓ(yᵢ) ≈ -λᵢ*yᵢ # p22: &quot;are not orthogonal, but satisfy the difference equation...&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/DiscreteChebyshev.jl#L4-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.FallingFactorial" href="#SpecialPolynomials.FallingFactorial"><code>SpecialPolynomials.FallingFactorial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FallingFactorial{T}</code></pre><p>Construct  a  polynomial with   respect to the basis <code>x⁰̲,  x¹̲, x²̲, …</code> where <code>xⁱ̲ = x  ⋅  (x-1) ⋅  (x-2)  ⋯ (x-i+1)</code> is the falling Pochhammer  symbol.  See <a href="https://en.wikipedia.org/wiki/Falling_and_rising_factorials">Falling factorial</a>  for several  facts about this  polynomial basis.</p><p>In <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a> connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(FallingFactorial, 3)
FallingFactorial(1.0⋅x³̲)

julia&gt; x = variable(Polynomial)
Polynomials.Polynomial(1.0*x)

julia&gt; p(x) ≈ x*(x-1)*(x-2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/FallingFactorial.jl#L2-L29">source</a></section></article><hr/><p>Some non-exported methods are available or define each of  the classical orthogonal polynomials:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.weight_function" href="#SpecialPolynomials.weight_function"><code>SpecialPolynomials.weight_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weight_function(p)
weight_function(::Type{P})</code></pre><p>For an orthogonal polynomial type, a function <code>w</code> with <code>∫ B_n(t) B_m(t) w(t) dt = 0</code> when <code>n</code> and <code>m</code> are not equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.generating_function" href="#SpecialPolynomials.generating_function"><code>SpecialPolynomials.generating_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generating_function(p)
generating_function(::Type{P})</code></pre><p>The generating function is a function defined by: <code>(t,x) -&gt; sum(t^n Pn(x) for n in 0:oo)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.abcde" href="#SpecialPolynomials.abcde"><code>SpecialPolynomials.abcde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abcde</code></pre><p>A named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (a⋅x²+b⋅x+c)*P₍ᵢ₊₂₎&#39;&#39; + (d⋅x + e) * P₍ᵢ₊₁₎ + λᵢ Pᵢ = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/cop.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.An" href="#SpecialPolynomials.An"><code>SpecialPolynomials.An</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">An(::Type{P},n)</code></pre><p>Orthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:</p><p><code>P_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}</code></p><p>If the polynomials are monic, this is usually parameterized as:</p><p><code>π_{n+1} = (x - α̃_n) π_n - β̃_n π_{n-1}</code></p><p>These functions are used through recursion when evaluating the polynomials, converting to <code>Polynomial</code> format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bn" href="#SpecialPolynomials.Bn"><code>SpecialPolynomials.Bn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Bn(::Type{P},n)
Bn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Cn" href="#SpecialPolynomials.Cn"><code>SpecialPolynomials.Cn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Cn(::Type{P},n)
Cn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L154-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.jacobi_matrix" href="#SpecialPolynomials.jacobi_matrix"><code>SpecialPolynomials.jacobi_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">jacobi_matrix(::Type{P}, n)</code></pre><p>The Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the <code>alphaᵢ</code> values, the off diagonal entries, the square root of the  <code>betaᵢ</code> values. This matrix has the properties that</p><ul><li>the eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.</li><li>the normalized eigenvectors have initial term proportional to the weights in a quadrature formula</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L251-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.gauss_nodes_weights" href="#SpecialPolynomials.gauss_nodes_weights"><code>SpecialPolynomials.gauss_nodes_weights</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gauss_nodes_weights(::Type{P}, n)</code></pre><p>Returns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.</p><p>When available, the values are computed through  the <code>FastGaussQuadratures</code> package.</p><p>For some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. &quot;A fast algorithm for the calculation of the roots of special functions.&quot; SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used.</p><p>For others the Jacobi matrix, J<em>n, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of J</em>n, the weights a scaling of the first component of the normalized eigen vectors (β_0 * [v[1] for v in vs])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/orthogonal.jl#L270-L281">source</a></section></article><h3 id="Defining-new-types"><a class="docs-heading-anchor" href="#Defining-new-types">Defining new types</a><a id="Defining-new-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-types" title="Permalink"></a></h3><p>A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  <code>abcde</code>  method are known.</p><p>Polynomial systems  can also be generated  through  an associated weight function.</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.WeightFunction" href="#SpecialPolynomials.WeightFunction"><code>SpecialPolynomials.WeightFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WeightFunction{T}</code></pre><p>A type for orthogonal polynomials relative to some weight function. The Wheeler or modified Chebyshev algorithm (<a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Gautschi</a>, <a href="https://doi.org/10.1063/1.4822929">Press and Teukolsky</a>) is used to generate the three-term recurrence relation.</p><p>If the second order differential equation, <code>σ⋅p&#39;&#39; + τ⋅p&#39; + λ⋅p=-</code> is known, using that to define the polynomial type would be preferred, as then several additional properties follow for free.</p><p>The key computation is the modified moment, <code>∫πⱼ dw</code> where <code>πⱼ</code> is the <code>j</code>th basis vector for an associated <em>monic</em> system, <code>P</code>, and <code>w</code> is the weight function.  These values are registered through the <code>@register_weight_function(Type, P, w)</code> macro, as illustrated in the examples.</p><p><strong>Example.</strong></p><p>Toy example with <code>ChebyshevU</code> being derived using the  <code>Chebyshev</code> system.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 Toy SP.WeightFunction   # register a  Toy  example

julia&gt; SP.@register_weight_function Toy MonicChebyshev SP.weight_function(ChebyshevU)

julia&gt; [SP.Cn.(Toy, 1:5) SP.Cn.(MonicChebyshevU, 1:5)]
5×2 Matrix{Float64}:
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25</code></pre><p>Elliptic orthogonal polynomials on  <code>[-1,1]</code>. Demo 2 of Gautschi.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; N,  ω² = 40, 0.999
(40, 0.999)

julia&gt; w(t) = ((1-ω²*t^2)*(1-t^2))^(-1/2)
w (generic function with 1 method)

julia&gt; SP.@register0 WF SP.WeightFunction

julia&gt; SP.@register_weight_function WF MonicChebyshev w

julia&gt; αs, βs = -SP.Bn.(WF, 0:5), SP.Cn.(WF, 0:5);

julia&gt; [αs βs]
6×2 Matrix{Float64}:
 -1.87309e-15  9.68226
 -7.11555e-18  0.793782
 -1.76472e-15  0.119868
 -2.89401e-15  0.22704
 -4.11827e-15  0.241061
 -5.47762e-15  0.245428</code></pre><p>The main computation involved in this is the modified moment, <code>νⱼ = ∫πⱼ dw</code>, computed with <code>QuadGK.quadgk</code>. For some examples, this computation can be completed directly and the <code>modified_moment</code> method may be overloaded for the type. This example is from Press and Teukolsky, where the modified moments are given through the function <code>v(j)</code> defined below.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials, SpecialFunctions

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; w(t) = -log(t)
w (generic function with 1 method)

julia&gt; SP.@register0 WF1 SP.WeightFunction   #  register  type WF1 as a weight function

julia&gt; SP.@register_weight_function WF1  MonicShiftedLegendre w

julia&gt; ν(j) = iszero(j) ? 1 : (-1)^j * gamma(j+1)^2 / (j*(j+1)*gamma(2j+1)) # help  out
ν (generic function with 1 method)

julia&gt; SP.modified_moment(::Type{WF1},  j::Int) = ν(j)

julia&gt; αs, βs = -SP.Bn.(WF1, 0:5), SP.Cn.(WF1, 0:5);

julia&gt; [αs βs]
6×2 Matrix{Float64}:
 -0.75      1.0
 -0.381148  0.423611
 -0.504058  0.172646
 -0.516236  0.203166
 -0.517168  0.222419
 -0.513854  0.239667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/WeightFunction.jl#L11-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.DiscreteWeightFunction" href="#SpecialPolynomials.DiscreteWeightFunction"><code>SpecialPolynomials.DiscreteWeightFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DiscreteWeightFunction</code></pre><p>For a discrete measure, <code>dλ = ∑ wᵢ δ(x - xᵢ)</code>, specified through two vectors, <code>xs</code> and <code>ws</code>, a collection of monic orthogonal polynomials is produced through Darboux&#39;s formula for <code>α_n</code> and <code>β_n</code> using the 3-term recurrence defined by <code>π_{n+1} = (x-α_n)⋅π_n - β_n⋅π_{n-1}</code> (<code>An=1</code>, <code>Bn=-α_n</code>, <code>Cn=β_n</code>) and the discrete Stieltjes method <a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Guatschi §3.1</a>.</p><p><strong>Example</strong></p><p>Discrete Chebyshev by its weight function (uniform  on 0,1,…,N-1)</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials;

julia&gt; N = 9
9

julia&gt; xs, ws = collect(0:N-1), ones(N);   # w(x) = ∑ wⱼ⋅δ(x-xⱼ)

julia&gt; SP.@register0 DWF DiscreteWeightFunction

julia&gt; SP.@register_discrete_weight_function(DWF, xs, ws)

julia&gt; [SP.Bn.(DWF, 0:N-1) SP.Cn.(DWF, 0:N-1)]
9×2 Matrix{Float64}:
 -4.0  9.0
 -4.0  6.66667
 -4.0  5.13333
 -4.0  4.62857
 -4.0  4.12698
 -4.0  3.53535
 -4.0  2.83217
 -4.0  2.01026
 -4.0  1.06667

julia&gt; i,j = 3,4; ## check  that ∫pᵢpⱼdw  = 0    for i,j=3,4

julia&gt; sum(basis(DWF,i)(x) *  basis(DWF,j)(x) * w for  (x,w) in zip(xs, ws))
5.684341886080802e-14

julia&gt; ## Gogin, Hirvensalo (https://doi.org/10.1007/s10958-017-3410-8) characterization
       D(k,N,x) =  sum((-1)^l * binomial(k+l,k) * binomial(N-l,k-l) *  SP.generalized_binomial(x,l) for l in 0:k)
D (generic function with 1 method)

julia&gt; x = variable()
Polynomials.Polynomial(x)

julia&gt; ps,qs = [D(k,N-1,x)  for  k in 0:N-1], [basis(DWF, k)(x) for k  in 0:N-1];

julia&gt; all(qs .* [p[end] for p  in ps] .≈ ps)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Orthogonal/Discrete/discrete-orthogonal.jl#L25-L82">source</a></section></article><h3 id="Interpolating-polynomials"><a class="docs-heading-anchor" href="#Interpolating-polynomials">Interpolating polynomials</a><a id="Interpolating-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractInterpolatingPolynomial" href="#SpecialPolynomials.AbstractInterpolatingPolynomial"><code>SpecialPolynomials.AbstractInterpolatingPolynomial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractInterpolatingPolynomial{T,X}</code></pre><p>Abstract type for interpolating polynomials.</p><p>These are polynomial representations of <code>p(x)</code> satisfying <code>p(x_i) = y_i</code> for a specified set of <code>x</code> values and <code>y</code> values.</p><p>For a collection of points <code>(x_0,y_0), ..., (x_n, y_n)</code> there is a <em>unique</em> polynomial of degree <code>n</code> or less satisfying <code>p(x_i)=y_i</code>. This fact allows the specification of <code>p(x)</code> using a vector of coefficients relative to some set of basis vectors.</p><p>The two main types, <code>Lagrange</code> and <code>Newton</code>, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like <code>convert(::Type, p)</code> will not work. Use <code>fit(Type, xs, p)</code>, as appropriate, instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Interpolating/interpolating.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Lagrange" href="#SpecialPolynomials.Lagrange"><code>SpecialPolynomials.Lagrange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Lagrange{N, S, R, T, X}</code></pre><p>Represent a polynomial in Lagrange form using nodes <code>xs</code>, weights <code>ws</code>, and coefficients <code>coeffs</code>. The Lagrange form does polynomial interpolation between <code>xs</code> and <code>ys</code> through <code>p(x) = Σ_{0..n} ℓ_i(x) y_i</code>, where if <code>ℓ(x) = prod(x-x_i)</code>, <code>w_i = 1/prod_{j≠i}(x_i - x_j)</code>, then <code>ℓ_i(x) = ℓ(x) w_i/(x-x_i)</code>. The <code>ℓ_i</code> satisfy <code>ℓ_i(x_j) = δ_{ij}</code>, so the coefficients are just the <code>ys</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1⋅P_0(x) + 2⋅P_1(x) + 3⋅P_2(x))

julia&gt; p.([1,2,3]) # the coefficients
3-element Vector{Int64}:
 1
 2
 3

julia&gt; convert(Polynomial,  p)
Polynomials.Polynomial(1.0*x)</code></pre><p>The instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as <code>variable</code> or <code>convert(Lagrange, ...)</code>. For the former we can  use an instance, for the latter we can use <code>fit</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1⋅P_0(x) + 2⋅P_1(x) + 3⋅P_2(x))

julia&gt; variable(p)
Lagrange(1⋅P_0(x) + 2⋅P_1(x) + 3⋅P_2(x))

julia&gt; q = Polynomial([0,0,1])
Polynomials.Polynomial(x^2)

julia&gt; qq = fit(Lagrange, p.xs, q)
Lagrange(1⋅P_0(x) + 4⋅P_1(x) + 9⋅P_2(x))

julia&gt; convert(Polynomial, qq)
Polynomials.Polynomial(1.0*x^2)</code></pre><p>Interpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. For <code>P=Chebyshvev</code> and <code>P=ChebyshevU</code>, the function <code>SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n)</code> will return a good choice of <code>n+1</code> points over <code>[-1,1]</code> along with precomputed weights.</p><pre><code class="language-julia-repl hljs">julia&gt; xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(Chebyshev, 64);


julia&gt; f(x) = exp(-x)*sinpi(x)
f (generic function with 1 method)

julia&gt; p = fit(Lagrange, xs, f.(xs));


julia&gt; degree(p)
64

julia&gt; maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) &lt;= 1e-14
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above example  is  more directly  done through <code>fit(Chebyshev, f, 64)</code>, though  the resulting polynomial will reference a different  basis.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Interpolating/Lagrange.jl#L1-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Newton" href="#SpecialPolynomials.Newton"><code>SpecialPolynomials.Newton</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Newton{N,S,T,X}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Newton_polynomial">Newton</a> interpolating polynomial uses a basis <code>1</code>, <code>(x-x_0)</code>, <code>(x-x_0)(x-x_1)</code>, ..., <code>(x-x0)(x-x1)⋅⋅⋅(x-x_{n-1})</code> and coefficients (in forward form) <code>f[x_0]</code>, <code>f[x_0,x_1]</code>, ...,<code>f[x_0,...,x_n]</code>. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.</p><p>The easiest way to construct an instance is with <code>fit</code>, as in:</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;

julia&gt; p = fit(Newton, xs, f)
Newton(5.0⋅p_1(x) + 6.0⋅p_2(x) + 1.0⋅p_3(x))

julia&gt; p.(xs) == f.(xs)  # p interpolates
true

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(1.0 - 2.0*x + 1.0*x^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Interpolating/Newton.jl#L1-L28">source</a></section></article><h3 id="Other-polynomials"><a class="docs-heading-anchor" href="#Other-polynomials">Other polynomials</a><a id="Other-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Other-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bernstein" href="#SpecialPolynomials.Bernstein"><code>SpecialPolynomials.Bernstein</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Bernstein{N, T, X}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Bernstein_polynomial">Bernstein  polynomial</a> is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, <code>𝐍</code>, this is a set of <code>𝐍+1</code> degree <code>𝐍</code> polynomials of the form: <code>β_{𝐍,ν} =  (ν choose 𝐍) x^ν  (1-x)^{𝐍-ν}</code>, <code>0 ≤ x ≤ 1.</code></p><p>The <code>Bernstein{𝐍,T}</code> type represents a polynomial of degree <code>𝐍</code> or less with a linear combination of the basis vectors using coefficients of type <code>T</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(Bernstein{3},  2)
Bernstein(1⋅β₂,₂(x))

julia&gt; convert(Polynomial, p)
Polynomials.Polynomial(1.0*x^2)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="https://github.com/tkoolen/StaticUnivariatePolynomials.jl">StaticUnivariatePolynomials</a> Offers a  more  performant version.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/7a8a2fc6e9d97835af5774be8ecc7534c9146906/src/Bernstein.jl#L3-L28">source</a></section></article><h4 id="Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-ᴺ-bᵢBᵢ(t)):"><a class="docs-heading-anchor" href="#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-ᴺ-bᵢBᵢ(t)):">Example of a <a href="https://pomax.github.io/bezierinfo/">Bezier</a> curve (parameterized by <code>r(t) = ∑₀ᴺ bᵢBᵢ(t)</code>):</a><a id="Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-ᴺ-bᵢBᵢ(t)):-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-a-[Bezier](https://pomax.github.io/bezierinfo/)-curve-(parameterized-by-r(t)-ᴺ-bᵢBᵢ(t)):" title="Permalink"></a></h4><pre><code class="language-julia hljs">bs = [[220, 260], [220, 40], [35, 100],  [120, 140]]

p = Bernstein(bs)
ts = range(0, stop=1, length=50)
ps = p.(ts)
xs, ys = [[pᵢ[1] for pᵢ ∈ ps], [pᵢ[2] for pᵢ ∈ ps]]
p = plot(xs, ys, legend=false)
scatter!(p, [b[1] for b in bs], [b[2] for b in bs])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">         ┌────────────────────────────────────────┐
   266.6 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⚬⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡸⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡜⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠁⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡸⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠚⠀⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠔⠊⚬⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠊⠀⠀⠀⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠰⡃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⠤⠒⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀│
         │⠀⚬⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠒⠒⠤⠤⠤⠤⠤⠤⠒⠒⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
         │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀│
    33.4 │⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⚬⠀│
         └────────────────────────────────────────┘
         ⠀29.45⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀225.55⠀</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.18 on <span class="colophon-date" title="Friday 3 June 2022 15:54">Friday 3 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
