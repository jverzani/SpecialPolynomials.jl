<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SpecialPolynomials.jl ¬∑ SpecialPolynomials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SpecialPolynomials</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>SpecialPolynomials.jl</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Orthogonal-polynomials"><span>Orthogonal polynomials</span></a></li><li><a class="tocitem" href="#Implemented-polynomial-types"><span>Implemented polynomial  types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SpecialPolynomials.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SpecialPolynomials.jl"><a class="docs-heading-anchor" href="#SpecialPolynomials.jl">SpecialPolynomials.jl</a><a id="SpecialPolynomials.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SpecialPolynomials.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/jverzani/SpecialPolynomials.jl">SpecialPolynomials.jl</a>.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>This package provides a number of different polynomial types to represent polynomials, extending the <code>Polynomials</code> package.</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractSpecialPolynomial" href="#SpecialPolynomials.AbstractSpecialPolynomial"><code>SpecialPolynomials.AbstractSpecialPolynomial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSpecialPolynomial{T}</code></pre><p>An abstract type to distinguish the different polynomial types in this package.</p><p>The concrete types specify different bases for the space of polynomials of degree <code>n</code> or less. </p><p>This package includes: </p><ul><li>several classic orthogonal polynomials.</li><li>Newton and Lagrange interpolating polynomials</li><li>Bernstein polynomials</li></ul><p>As many of the methods for the base <code>Polynomials</code> class are directly coded if possible, but quite a few depend on conversion to the base <code>Polynomial</code> type (which uses the standard polynomial basis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/abstract.jl#L1-L17">source</a></section></article><h2 id="Orthogonal-polynomials"><a class="docs-heading-anchor" href="#Orthogonal-polynomials">Orthogonal polynomials</a><a id="Orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Orthogonal-polynomials" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractOrthogonalPolynomial" href="#SpecialPolynomials.AbstractOrthogonalPolynomial"><code>SpecialPolynomials.AbstractOrthogonalPolynomial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractOrthogonalPolynomial{T}</code></pre><p>Type to represent systems of orthogonal polynomials. These polynomials have  several properties, including an accompanying inner product satsifying  <code>‚ü®y·µ¢, y‚±º‚ü© = c·µ¢Œ¥·µ¢‚±º</code>.</p><p>In addition to methods inherited from the underlying <code>AbstractPolynomial</code>  type, orthogonal polynomial  types may have methods   <code>weight_function</code>, <code>generating_function</code>, <code>leading_term</code>, norm2<code>,</code>jacobi<em>matrix<code>, and</code>gauss</em>nodes_weights`,  though none are  exported.</p><p>Subtypes of <code>AbstractCOP &lt;: AbstractOrthogonalPolynomial</code> utilize the fact that the basis  polynomials  satisfy</p><p><code>(ax¬≤ + bx + c)y·µ¢&#39;&#39;(x) + (dx+e)y·µ¢&#39;(x) + Œª·µ¢y·µ¢(x) = 0</code> (or a discrete analogue)</p><p>where the structural relations are functions of <code>a,b,c,d,e</code>. These allow default definitions for polynomial evaluation,   addition, multiplication, differentiation, integration, and  conversion to and from  the <code>Polynomial</code> type (the <code>FallingFactorial</code> type in the discrete  c case),</p><p>A key structural relation is the three-term recursion,  <code>y·µ¢‚Çä‚ÇÅ =  (A·µ¢x +  B·µ¢)y·µ¢ -  C·µ¢y·µ¢‚Çã‚ÇÅ</code>. For systems  specfied by  a  weight function, the  values of <code>A·µ¢</code>, <code>B·µ¢</code>, and <code>C·µ¢</code> can  be  generated, yielding formulas for polynomial evaluation, addition, and conversion to the <code>Polynomial</code>  type throughe evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L10-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractCCOP" href="#SpecialPolynomials.AbstractCCOP"><code>SpecialPolynomials.AbstractCCOP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractCCOP{T,N} &lt;:  AbstractCOP{T,N}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a>, a family <code>y(x)=p_n(x)=k_x‚ãÖx^n +  ...</code>   for  <code>n  ‚àà  {0, 1,‚Ä¶}, k_n ‚â† 0</code> of polynomials is a family of classic <em>continuous</em> orthogonal polynomials if each is  a solution of the differential equation</p><p><code>(a‚ãÖx¬≤+b‚ãÖx+c) ‚ãÖ y·µ¢&#39;&#39; + (d‚ãÖx + e) ‚ãÖ y·µ¢&#39; + Œª·µ¢‚ãÖ y·µ¢ = 0.</code></p><p>A family is characterized, up to choice of leading term, by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>œÉ = (a‚ãÖx¬≤+b‚ãÖx+c)</code>, <code>œÑ = (d‚ãÖx + e)</code>.</p><p>From these  5  coefficients several structural  equations are represented. For example the three-point recusion.</p><p><code>P‚Çç·µ¢‚Çä‚ÇÅ) = (A·µ¢‚ãÖx + B·µ¢) * P·µ¢ - C·µ¢ *  P‚Çç·µ¢‚Çã‚ÇÅ‚Çé</code>,</p><p>where <code>A·µ¢,B·µ¢,C·µ¢</code> can be represented in formulas involving just  <code>a,b,c,d,e</code> and <code>i</code>.</p><p>Rearranging   gives the structural equation:</p><p><code>x‚ãÖp_n   = [an, bn, cn] ‚ãÖ [p_{n+1}, p_n, p_{n-1}]</code>  (Eqn (7))</p><p>The other structural equations are (equation  references are from Koepf and Schmersau):</p><p><code>œÉ‚ãÖp&#39;_n  = [Œ±n, Œ≤n, Œ≥n] ‚ãÖ  [p_{n+1}, p_n, p_{n-1}]</code> (Eqn (9), n ‚â• 1)</p><p><code>p_n = [aÃÇn, bÃÇn, cÃÇn]  ‚ãÖ  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn (19))</p><p><code>x‚ãÖp&#39;_n  = [Œ±·¥µn, Œ≤·¥µn, Œ≥·¥µn] ‚ãÖ  [p&#39;_{n+1}, p&#39;_n, p&#39;_{n-1}]</code> (Eqn  (14))</p><p>Using (7), Clenshaw polynomial evaluation using the three  point recursion is defined.</p><p>Using (19), expressions for derivatives are found.</p><p>Using  (19), expressions for integration are found (p7).</p><p>Using their theorems 2,4, and 5, connection coefficients, <code>C(n,m)</code> satisfying  <code>P_n(x) =  ‚àë  C(n,m)  Q_m(x) (n ‚â• 0, 0 ‚â§  m ‚â§ n)</code> are  found. These  allow  fallback  definitions for <code>convert(Polynomial,p)</code>,  <code>convert(P, p::Polynomial)</code>, <code>convert(P{Œ±‚Ä¶}, p::P(Œ≤‚Ä¶))</code> and through composition polynomial  multiplication,  <code>p*q</code>.</p><p>Subtypes of <code>AbstractCCOP</code> are  created through  the <code>@register0</code> or  <code>@registerN</code> macros, where the  <code>N</code>  macro  is used  if parameters are  needed to describe the family.</p><p>If non-monic versions are desired, then the  leading  term can be  specified through <code>kn()</code> (which by default is defined by the  method <code>k1k0(P,i)</code>, the ratio of  <code>k·µ¢‚Çä‚ÇÅ/k·µ¢</code>).  The <code>@register_monic</code> macro is useful  for creating  monic versions through  method delegation from the common non-monic systems. Similarly, the <code>@register_shifted</code> macro is useful  to provide shifted versions (cf. <a href="#SpecialPolynomials.ShiftedLegendre"><code>ShiftedLegendre</code></a>).</p><p>Registering a system, defining an <code>abcde</code> method, and optionally defining <code>k1k0</code> is usually sufficient to define a new system, though the general equations may need specializations when algebraic cancellation is required.</p><p>The defaults for evaluation and multplication are generally an order of magnitude slower than a directly defined function. For some families this is done (e.g. <code>Chebyshev</code>,<code>ChebyshevU</code>, <code>Hermite</code>, <code>Laguerre</code>), but not all.</p><p><strong>Example</strong></p><p>For this example, the value of <code>Bn</code> at <code>0</code> needs help:</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 MonicLegendre‚Ä≤ SP.AbstractCCOP0

julia&gt; SP.:œü(::Type{&lt;:MonicLegendre‚Ä≤}) = Legendre

julia&gt; SP.@register_monic MonicLegendre‚Ä≤  # use  œü to delegate methods

julia&gt; ùêê  =  Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{ùêê})
Polynomial(x)

julia&gt; [basis(MonicLegendre‚Ä≤{ùêê}, i)(x) for i  in 0:5]
6-element Array{Polynomial{Rational{Int64}},1}:
 Polynomial(1//1)
 Polynomial(x)
 Polynomial(-1//3 + x^2)
 Polynomial(-3//5*x + x^3)
 Polynomial(3//35 - 6//7*x^2 + x^4)
 Polynomial(5//21*x - 10//9*x^3 + x^5)</code></pre><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/ccop.jl#L6-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractCDOP" href="#SpecialPolynomials.AbstractCDOP"><code>SpecialPolynomials.AbstractCDOP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> AbstractCDOP{T,N} &lt;: AbstractCOP{T,N}</code></pre><p>Following <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf  and Schmersau</a>, a family <code>y(x)=p_n(x)=k_x‚ãÖx^n +  ...</code>   for  <code>n  ‚àà  {0, 1,‚Ä¶}, k_n ‚â† 0</code> of polynomials is a family of classic <em>discrete</em> orthogonal polynomials if it  is  a solution of a differential equation</p><p><code>(a‚ãÖx¬≤+b‚ãÖx+c) ‚ãÖ Œî‚àáy + (d‚ãÖx + e) ‚ãÖ ‚àá&#39; + Œª·µ¢‚ãÖ y = 0</code>,</p><p>where  <code>Œîy(x) = y(x+1) - y(x)</code> and <code>‚àáy(x) = y(x) - y(x-1)</code>.</p><p>A family is characterized by the 5 coefficients: <code>a,b,c,d,e</code>. Let <code>œÉ = (a‚ãÖx¬≤+b‚ãÖx+c)</code>, <code>œÑ = (d‚ãÖx + e).</code></p><p>As in the classical-continuous-orthogonal-polynomial case <a href="#SpecialPolynomials.AbstractCCOP"><code>AbstractCCOP</code></a>, from these 5 values the cofficients in the there-point recursion, and other structural equations can be represented. These allow polynomial multiplication, integration, differentiation, conversion, etc. to be defined generically.</p><p><a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> present an encyclopedia of formula characterizing families of orthogonal polynomials. </p><p>For example, on p29 they give  formulas for Hahn polynomials through:</p><p><code>n(n+Œ±+Œ≤+1)y(x) = B(x)y(x+1) -[B(x)+D(x)]y(x) + D(x)y(x-1)</code>,  with  explicit values  for  <code>B</code> and <code>D</code>. Reexpressing gives: <code>BŒîy(x) - D‚àáy(x) -Œª y(x)  = 0</code>. From the rexpressed Eqn (4) for Koepf &amp; Schemersau we have the identification: <code>œÉ+œÑ =  B; œÉ=D</code>,  so  <code>œÑ=B-D</code>. From this <code>a,b,c,d,e</code> can be  gleaned.</p><p>The above, is termed the eigevalue equation (e.g. <a href="https://arxiv.org/pdf/1609.07291.pdf">Goertz and Offner</a>), as it can be reexpressed as </p><p><code>Œî(D(x)‚ãÖœâ(x)‚ãÖ‚àáy·µ¢(x) = Œª·µ¢‚ãÖœâ(x)‚ãÖy·µ¢(x)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/cdop.jl#L4-L41">source</a></section></article><h2 id="Implemented-polynomial-types"><a class="docs-heading-anchor" href="#Implemented-polynomial-types">Implemented polynomial  types</a><a id="Implemented-polynomial-types-1"></a><a class="docs-heading-anchor-permalink" href="#Implemented-polynomial-types" title="Permalink"></a></h2><h3 id="Classical-continuous-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-continuous-orthogonal-polynomials">Classical continuous orthogonal polynomials</a><a id="Classical-continuous-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-continuous-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical continuous  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Legendre" href="#SpecialPolynomials.Legendre"><code>SpecialPolynomials.Legendre</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Legendre{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Legendre_polynomials">Legendre</a> polynomials. These have weight function <code>w(x) = 1</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Legendre([1,2,3])
Legendre(1‚ãÖP‚ÇÄ(x) + 2‚ãÖP‚ÇÅ(x) + 3‚ãÖP‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.5 + 2.0*x + 4.5*x^2)

julia&gt; p2m, p2m1 = basis.(Legendre, (8,9)) # evaluation P_{2m+k}(-1) =  (-1)^k
(Legendre(1.0‚ãÖP‚Çà(x)), Legendre(1.0‚ãÖP‚Çâ(x)))

julia&gt; p2m(-1) == 1
false

julia&gt; p2m1(-1) == -1
false

julia&gt; n = 5  # verify  Rodrigues&#39; formula 
5

julia&gt; x = Polynomial(:x)
Polynomial(x)

julia&gt; derivative((x^2-1)^n, n) - 2^n *  factorial(n) * basis(Legendre, n)
Polynomial(1.8189894035458565e-12*x)

julia&gt; p4, p5  =  basis.(Legendre, (4,5)) # verify  orthogonality  of  P‚ÇÑ,P‚ÇÖ
(Legendre(1.0‚ãÖP‚ÇÑ(x)), Legendre(1.0‚ãÖP‚ÇÖ(x)))

julia&gt; SpecialPolynomials.innerproduct(Legendre, p4,  p5)
-1.543670556388031e-16</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Legendre.jl#L10-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Chebyshev" href="#SpecialPolynomials.Chebyshev"><code>SpecialPolynomials.Chebyshev</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Chebyshev{&lt;:Number}(coeffs::AbstractVector, var=:x)</p><p>Chebyshev polynomial of the first kind.</p><p>Construct a polynomial from its coefficients <code>a</code>, lowest order first, optionally in terms of the given variable <code>x</code>. <code>x</code> can be a character, symbol, or string.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; Chebyshev([1, 0, 3, 4])
Chebyshev(1‚ãÖT‚ÇÄ(x) + 3‚ãÖT‚ÇÇ(x) + 4‚ãÖT‚ÇÉ(x))

julia&gt; Chebyshev([1, 2, 3, 0], :s)
Chebyshev(1‚ãÖT‚ÇÄ(s) + 2‚ãÖT‚ÇÅ(s) + 3‚ãÖT‚ÇÇ(s))

julia&gt; one(Chebyshev)
Chebyshev(1.0‚ãÖT‚ÇÄ(x))</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is copied from the <code>ChebyshevT</code> example from the <code>Polynomials</code> package by Miles Lucas.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The sample chapter available online of <a href="https://archive.siam.org/books/ot99/OT99SampleChapter.pdf">Numerical Methods for Special Functions&quot; by Amparo Gil, Javier Segura, and Nico Temme</a> gives a very nice overview of these polynomials.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Chebyshev.jl#L5-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ChebyshevU" href="#SpecialPolynomials.ChebyshevU"><code>SpecialPolynomials.ChebyshevU</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ChebyshevU{T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Chebyshev_polynomials">Chebyshev</a> polynomials of the second kind. These have weight function  <code>w(x) = sqrt(1-x^2)</code> over the domain <code>[-1,1]</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = ChebyshevU([1,2,3])
ChebyshevU(1‚ãÖU‚ÇÄ(x) + 2‚ãÖU‚ÇÅ(x) + 3‚ãÖU‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(-2 + 4*x + 12*x^2)

julia&gt; derivative(p)
ChebyshevU(4.0‚ãÖU‚ÇÄ(x) + 12.0‚ãÖU‚ÇÅ(x))

julia&gt; roots(p)
2-element Array{Float64,1}:
 -0.6076252185107651
  0.27429188517743175</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Chebyshev.jl#L424-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Laguerre" href="#SpecialPolynomials.Laguerre"><code>SpecialPolynomials.Laguerre</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Laguerre{Œ±, T &lt;: Number}</p><p>The  Laguerre polynomials have weight function <code>x^Œ± * exp(-x)</code> over the domain <code>[0, oo)</code>. The parameter <code>Œ±</code> is specified through the constructor.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{1/2}([1,2,3])
Laguerre{0.5}(1‚ãÖL·µÖ‚ÇÄ(x) + 2‚ãÖL·µÖ‚ÇÅ(x) + 3‚ãÖL·µÖ‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(9.625 - 9.5*x + 1.5*x^2)</code></pre><p>The Laguerre polynomials are the case <code>Œ±=0</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Laguerre{0}([1,2,3])
Laguerre{0}(1‚ãÖL‚ÇÄ(x) + 2‚ãÖL‚ÇÅ(x) + 3‚ãÖL‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(6.0 - 8.0*x + 1.5*x^2)

julia&gt; phi(u, i) = derivative(u) -  u # verify Rodrigues&#39; formula for small n; n! L_n = (d/dx-1)^n x^n
phi (generic function with 1 method)

julia&gt; x = Polynomial(:x)
Polynomial(x)

julia&gt; n = 7
7

julia&gt; factorial(n) * basis(Laguerre{0}, n) - foldl(phi, 1:n, init=x^n)
Polynomial(-5.4569682106375694e-12 + 1.4551915228366852e-11*x - 7.275957614183426e-12*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Laguerre.jl#L4-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Hermite" href="#SpecialPolynomials.Hermite"><code>SpecialPolynomials.Hermite</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hermite</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials have two versions the physicists (<code>Hermite</code>  or  <code>H</code>) and the probablalists (<code>ChebyshevHermite</code> or  <code>H‚Çë</code>). They are  related through  <code>H·µ¢(x) =  2^(i/2) H‚Çë·µ¢(‚àö2 x)</code>.</p><p>The Hermite   polynomials have weight  function <code>w(x)=exp(-x^2/2)</code> and domain the real line.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Polynomials,  SpecialPolynomials

julia&gt; x = variable(Polynomial{Rational{Int}})
Polynomial(x)

julia&gt; [basis(Hermite, i)(x) for i in 0:5]
6-element Array{Polynomial{Float64},1}:
 Polynomial(1.0)
 Polynomial(2.0*x)
 Polynomial(-2.0 + 4.0*x^2)
 Polynomial(-12.0*x + 8.0*x^3)
 Polynomial(12.0 - 48.0*x^2 + 16.0*x^4)
 Polynomial(120.0*x - 160.0*x^3 + 32.0*x^5)

julia&gt; [basis(ChebyshevHermite, i)(x) for i in 0:5]
6-element Array{Polynomial{Float64},1}:
 Polynomial(1.0)
 Polynomial(1.0*x)
 Polynomial(-1.0 + 1.0*x^2)
 Polynomial(-3.0*x + 1.0*x^3)
 Polynomial(3.0 - 6.0*x^2 + 1.0*x^4)
 Polynomial(15.0*x - 10.0*x^3 + 1.0*x^5)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The Hermite family needs help, as the computed values for <code>Bn</code>,and,<code>Cn</code> are  both 0.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Hermite.jl#L7-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ChebyshevHermite" href="#SpecialPolynomials.ChebyshevHermite"><code>SpecialPolynomials.ChebyshevHermite</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ChebyshevHermite</code></pre><p>Type for the Probabalist&#39;s  <a href="https://en.wikipedia.org/wiki/Hermite_polynomials">Hermite</a> polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Hermite.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Gegenbauer" href="#SpecialPolynomials.Gegenbauer"><code>SpecialPolynomials.Gegenbauer</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><p>Gegenbauer{Œ±, T &lt;: Number}</p><p>The Gegenbauer polynomials have weight function <code>(1-x^2)^(Œ±-1/2)</code> over the domain <code>[-1,1]</code>. The parameter <code>Œ±</code> is specified in the constructor. These are also called the ultra-spherical polynomials. The Legendre polynomials are the specialization  <code>Gegenbauer{1/2}</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Gegenbauer{1/2}([1,2,3])
Gegenbauer{0.5}(1‚ãÖC·µÖ‚ÇÄ(x) + 2‚ãÖC·µÖ‚ÇÅ(x) + 3‚ãÖC·µÖ‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.5 + 2.0*x + 4.5*x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Gegenbauer.jl#L5-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Jacobi" href="#SpecialPolynomials.Jacobi"><code>SpecialPolynomials.Jacobi</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Jacobi{Œ±,  Œ≤, T}</code></pre><p>Implements the <a href="https://en.wikipedia.org/wiki/Jacobi_polynomials">Jacobi</a> polynomials. These have weight function <code>w(x) = (1-x)^Œ± ‚ãÖ (1+x)^Œ≤</code> over the domain <code>[-1,1]</code>. Many orthogonal polynomial types are special cases. The parameters are  specified to the constructors:</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = Jacobi{-1/2, -1/2}([0,0,1])
Jacobi{-0.5,-0.5}(1‚ãÖJ·µÖ·µù‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(-0.375 + 0.75*x^2)

julia&gt; monic(p) = (q=convert(Polynomial,p); q/q[end])
monic (generic function with 1 method)

julia&gt; monic(p) ‚âà  monic(basis(Chebyshev, 2))
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Jacobi.jl#L5-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bessel" href="#SpecialPolynomials.Bessel"><code>SpecialPolynomials.Bessel</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bessel{Œ±}</code></pre><p>Implements the <a href="https://dlmf.nist.gov/18.34">Bessel</a> polynomials, introduced by <a href="https://www.ams.org/journals/tran/1949-065-01/S0002-9947-1949-0028473-1/S0002-9947-1949-0028473-1.pdf">Krall and Frink</a> (with <code>b=2</code>). The  case <code>a=2</code> corresponds to the  <a href="https://en.wikipedia.org/wiki/Bessel_polynomials">Bessel</a> polynomials of Wikipedia. The Bessel  polynomials are not orthogonal over  a domain of the real  line, rather over an arbitray curve in the complex plane enclosing the  origin.  The weight  function is <code>œÅ(x)=(2œÄi)^(-1)‚àëŒì(Œ±)/Œì(Œ±+n-1)(-Œ≤/x)^n</code>,   where <code>Œ≤=2</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; ùêê = Rational{Int}
Rational{Int64}

julia&gt; x = variable(Polynomial{ùêê})
Polynomial(x)

julia&gt; [basis(Bessel{3//2, ùêê}, i)(x) for i in 0:5]
6-element Array{Polynomial{Rational{Int64}},1}:
 Polynomial(1//1)
 Polynomial(1//1 + 3//4*x)
 Polynomial(1//1 + 5//2*x + 35//16*x^2)
 Polynomial(1//1 + 21//4*x + 189//16*x^2 + 693//64*x^3)
 Polynomial(1//1 + 9//1*x + 297//8*x^2 + 1287//16*x^3 + 19305//256*x^4)
 Polynomial(1//1 + 55//4*x + 715//8*x^2 + 10725//32*x^3 + 182325//256*x^4 + 692835//1024*x^5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Bessel.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.ShiftedLegendre" href="#SpecialPolynomials.ShiftedLegendre"><code>SpecialPolynomials.ShiftedLegendre</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftedLegendre</code></pre><p>Type for the shifted Legendre polynomials: <code>PÀ¢·µ¢(x) =  P·µ¢(2x-1)</code> for <code>x ‚àà [0,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Legendre.jl#L129-L133">source</a></section></article><h3 id="Classical-discrete-orthogonal-polynomials"><a class="docs-heading-anchor" href="#Classical-discrete-orthogonal-polynomials">Classical discrete orthogonal polynomials</a><a id="Classical-discrete-orthogonal-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-discrete-orthogonal-polynomials" title="Permalink"></a></h3><p>There are  several classical discrete  orthogonal polynomials available:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Charlier" href="#SpecialPolynomials.Charlier"><code>SpecialPolynomials.Charlier</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Charlier{Œº}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw ¬ß1.12</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/Charlier.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Krawchouk" href="#SpecialPolynomials.Krawchouk"><code>SpecialPolynomials.Krawchouk</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> Krawchouk{p,ùêç}</code></pre><p>Also spelled  Krawtchouk,  Kravhcuk,‚Ä¶.</p><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw ¬ß1.10</a>;  see  also  <a href="https://arxiv.org/pdf/1101.1798.pdf">Coleman</a> for a different  parameterization.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/Krawchouk.jl#L5-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Meixner" href="#SpecialPolynomials.Meixner"><code>SpecialPolynomials.Meixner</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Meixner{Œ≥,Œº}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw ¬ß1.9</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/Meixner.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Hahn" href="#SpecialPolynomials.Hahn"><code>SpecialPolynomials.Hahn</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Hahn{Œ±,Œ≤,ùêç}</code></pre><p>References: <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw ¬ß1.5</a></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In  <a href="https://arxiv.org/pdf/math/9602214.pdf">Koekoek and Swarttouw</a> sections 1.3, 1.4, and 1.6  are other  Hahn-type polynomials,  not  implemented here.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/Hahn.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.DiscreteChebyshev" href="#SpecialPolynomials.DiscreteChebyshev"><code>SpecialPolynomials.DiscreteChebyshev</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteChebyshev</code></pre><p>This uses p22 of <a href="https://arxiv.org/pdf/math/9703217.pdf"></a>  to define a two-parameter  family of <em>non</em> orthogonal polynomials. See  the example  in <a href="#SpecialPolynomials.DiscreteWeightFunction"><code>DiscreteWeightFunction</code></a> for implementing  the <a href="https://en.wikipedia.org/wiki/Discrete_Chebyshev_polynomials">DiscreteChebyshev</a>  polynomials  from Wikipedia.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; import SpecialPolynomials: Œî‚Çì, ‚àá‚Çì

julia&gt; Œ±,Œ≤ = 1/2, 1
(0.5, 1)

julia&gt; P  = DiscreteChebyshev{Œ±,Œ≤}
DiscreteChebyshev{0.5,1,T,N} where N where T

julia&gt; i = 5
5

julia&gt; y·µ¢ = basis(P, i)
DiscreteChebyshev(1.0‚ãÖK‚ÅΩ·µÖ·µù‚Åæ‚ÇÖ(x))

julia&gt; x = variable(P)
DiscreteChebyshev(- 2.0‚ãÖK‚ÅΩ·µÖ·µù‚Åæ‚ÇÄ(x) + 2.0‚ãÖK‚ÅΩ·µÖ·µù‚Åæ‚ÇÅ(x))

julia&gt; a,b,c,d,e = SpecialPolynomials.abcde(P)
(a = 0, b = 0, c = 1, d = 0.5, e = 1)

julia&gt; Œª·µ¢  = -(a*i*(i-1)  + d*i)
-2.5

julia&gt; Œî‚Çì(‚àá‚Çì(y·µ¢)) +  (Œ±*x + Œ≤) * Œî‚Çì(y·µ¢) ‚âà -Œª·µ¢*y·µ¢ # p22: &quot;are not orthogonal, but satisfy the difference equation...&quot;
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/DiscreteChebyshev.jl#L4-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.FallingFactorial" href="#SpecialPolynomials.FallingFactorial"><code>SpecialPolynomials.FallingFactorial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FallingFactorial{T}</code></pre><p>Construct  a  polynomial with   respect to the basis <code>x‚Å∞Ã≤,  x¬πÃ≤, x¬≤Ã≤, ‚Ä¶</code> where  <code>x‚Å±Ã≤ = x  ‚ãÖ  (x-1) ‚ãÖ  (x-2)  ‚ãØ (x-i+1)</code> is the falling Pochhammer  symbol.  See  <a href="https://en.wikipedia.org/wiki/Falling_and_rising_factorials">Falling factorial</a>  for several  facts about this  polynomial basis.</p><p>In <a href="https://arxiv.org/pdf/math/9703217.pdf">Koepf and Schmersau</a> connection coefficients between the falling factorial polynomial system and classical discrete orthogonal polynomials are given.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(FallingFactorial, 3)
FallingFactorial(1.0‚ãÖx¬≥Ã≤)

julia&gt; x = variable(Polynomial)
Polynomial(x)

julia&gt; p(x) ‚âà x*(x-1)*(x-2)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/FallingFactorial.jl#L2-L29">source</a></section></article><hr/><p>Some non-exported methods are available or define each of  the classical orthogonal polynomials:</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.weight_function" href="#SpecialPolynomials.weight_function"><code>SpecialPolynomials.weight_function</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">weight_function(p)
weight_function(::Type{P})</code></pre><p>For an orthogonal polynomial type, a function <code>w</code> with <code>‚à´ B_n(t) B_m(t) w(t) dt = 0</code> when n and m are not equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L81-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.generating_function" href="#SpecialPolynomials.generating_function"><code>SpecialPolynomials.generating_function</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generating_function(p)
generating_function(::Type{P})</code></pre><p>The generating function is a function defined by: <code>(t,x) -&gt; sum(t^n Pn(x) for n in 0:oo)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.abcde" href="#SpecialPolynomials.abcde"><code>SpecialPolynomials.abcde</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><p>abcde</p><p>A named tuple returning  the  constants a,b,c,d,e  for a CCOP type with (a‚ãÖx¬≤+b‚ãÖx+c)*P‚Çç·µ¢‚Çä‚ÇÇ‚Çé&#39;&#39; + (d‚ãÖx + e) * P‚Çç·µ¢‚Çä‚ÇÅ‚Çé + Œª·µ¢ P·µ¢ = 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/cop.jl#L36-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.An" href="#SpecialPolynomials.An"><code>SpecialPolynomials.An</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">An(::Type{P},n)</code></pre><p>Orthogonal polynomials defined by a weight function satisfy a three point recursion formula of the form:</p><p><code>P_{n+1} = (A_n x + B_n) P_{n} - C_n P_{n-1}</code></p><p>If the polynomials are monic, this is usually parameterized as:</p><p><code>œÄ_{n+1} = (x - Œ±ÃÉ_n) œÄ_n - Œ≤ÃÉ_n œÄ_{n-1}</code></p><p>These functions are used through recursion when evaluating the polynomials, converting to <code>Polynomial</code> format, for constructing the Vandermonde matrix, for construction the Jacobi matrix, and elsewhere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L122-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bn" href="#SpecialPolynomials.Bn"><code>SpecialPolynomials.Bn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Bn(::Type{P},n)
Bn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L138-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Cn" href="#SpecialPolynomials.Cn"><code>SpecialPolynomials.Cn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Cn(::Type{P},n)
Cn(p::P, n)</code></pre><p>cf. <a href="#SpecialPolynomials.An"><code>An()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.jacobi_matrix" href="#SpecialPolynomials.jacobi_matrix"><code>SpecialPolynomials.jacobi_matrix</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobi_matrix(::Type{P}, n)</code></pre><p>The Jacobi Matrix is a symmetric tri-diagonal matrix. The diagonal entries are the <code>alpha_i</code> values, the off diagonal entries, the square root of the  <code>beta_i</code> values. This matrix has the properties that</p><ul><li>the eigenvalues are the roots of the corresponding basis vector. As these roots are important in quadrature, and finding eigenvalues of a symmetric tri-diagonal matrix yields less error than finding the eigenvalues of the companion matrix, this can be used for higher degree basis polynomials.</li><li>the normalized eigenvectors have initial term proportional to the weights in a quadrature formula</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L237-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.gauss_nodes_weights" href="#SpecialPolynomials.gauss_nodes_weights"><code>SpecialPolynomials.gauss_nodes_weights</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gauss_nodes_weights(::Type{P}, n)</code></pre><p>Returns a tuple of nodes and weights for Gauss quadrature for the given orthogonal type.</p><p>When available, the values are computed through  the <code>FastGaussQuadratures</code> package.</p><p>For some types, a method from  A. Glaser, X. Liu, and V. Rokhlin. &quot;A fast algorithm for the calculation of the roots of special functions.&quot; SIAM J. Sci. Comput., 29 (2007), 1420-1438. is used. </p><p>For others the Jacobi matrix, J<em>n, for which the Golub-Welsch] algorithm The nodes  are computed from the eigenvalues of J</em>n, the weights a scaling of the first component of the normalized eigen vectors (Œ≤_0 * [v[1] for v in vs])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/orthogonal.jl#L253-L264">source</a></section></article><h3 id="Defining-new-types"><a class="docs-heading-anchor" href="#Defining-new-types">Defining new types</a><a id="Defining-new-types-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-new-types" title="Permalink"></a></h3><p>A new polynomial system  of classical type can  be specified fairly  succinctly,  provided the 5 constants  for the  <code>abcde</code>  method are known.</p><p>Polynomial systems  can also be generated  through  an associated weight function.</p><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.WeightFunction" href="#SpecialPolynomials.WeightFunction"><code>SpecialPolynomials.WeightFunction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WeightFunction{T}</code></pre><p>A type for orthogonal polynomials relative to some weight function. The Wheeler or modified Chebyshev algorithm (<a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Gautschi</a>, <a href="https://doi.org/10.1063/1.4822929">Press and Teukolsky</a>) is used to generate the three-term recurrence relation. </p><p>If the second order differential equation, <code>œÉ‚ãÖp&#39;&#39; + œÑ‚ãÖp&#39; + Œª‚ãÖp=-</code> is known, using that to define the polynomial type would be preferred, as then several additional properties follow for free.</p><p>The key computation is the modified moment, <code>‚à´œÄ‚±º dw</code> where <code>œÄ‚±º</code> is the <code>j</code>th basis vector for an associated <em>monic</em> system, <code>P</code>, and <code>w</code> is the weight function.  These values are registered through the <code>@register_weight_function(Type, P, w)</code> macro, as illustrated in the examples.</p><p><strong>Example.</strong></p><p>Toy example with <code>ChebyshevU</code> being derived using the  <code>Chebyshev</code> system.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials
SpecialPolynomials

julia&gt; SP.@register0 Toy SP.WeightFunction   # register a  Toy  example

julia&gt; SP.@register_weight_function Toy MonicChebyshev SP.weight_function(ChebyshevU)

julia&gt; [SP.Cn.(Toy, 1:5) SP.Cn.(MonicChebyshevU, 1:5)]
5√ó2 Array{Float64,2}:
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25
 0.25  0.25</code></pre><p>Elliptic orthogonal polynomials on  <code>[-1,1]</code>. Demo 2 of Gautschi.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; N,  œâ¬≤ = 40, 0.999
(40, 0.999)

julia&gt; w(t) = ((1-œâ¬≤*t^2)*(1-t^2))^(-1/2)
w (generic function with 1 method)

julia&gt; SP.@register0 WF SP.WeightFunction

julia&gt; SP.@register_weight_function WF MonicChebyshev w

julia&gt; Œ±s, Œ≤s = -SP.Bn.(WF, 0:5), SP.Cn.(WF, 0:5);

julia&gt; [Œ±s Œ≤s]
6√ó2 Array{Float64,2}:
 -1.87309e-15  9.68226
  2.35136e-15  0.793782
 -8.51176e-16  0.119868
 -3.06017e-15  0.22704
 -3.09826e-16  0.241061
  2.37296e-15  0.245429</code></pre><p>The main computation involved in this is the modified moment, <code>ŒΩ‚±º = ‚à´œÄ‚±º dw</code>, computed with <code>QuadGK.quadgk</code>. For some examples, this computation can be completed directly and the <code>modified_moment</code> method may be overloaded for the type. This example is from Press and Teukolsky, where the modified moments are given through the function <code>v(j)</code> defined below.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials, SpecialFunctions

julia&gt; const SP=SpecialPolynomials
SpecialPolynomials

julia&gt; w(t) = -log(t)
w (generic function with 1 method)

julia&gt; SP.@register0 WF1 SP.WeightFunction   #  register  type WF1 as a weight function

julia&gt; SP.@register_weight_function WF1  MonicShiftedLegendre w

julia&gt; ŒΩ(j) = iszero(j) ? 1 : (-1)^j * gamma(j+1)^2 / (j*(j+1)*gamma(2j+1)) # help  out
ŒΩ (generic function with 1 method)

julia&gt; SP.modified_moment(::Type{WF1},  j::Int) = ŒΩ(j)

julia&gt; Œ±s, Œ≤s = -SP.Bn.(WF1, 0:5), SP.Cn.(WF1, 0:5);

julia&gt; [Œ±s Œ≤s]
6√ó2 Array{Float64,2}:
 -0.75      1.0
 -0.381148  0.423611
 -0.504058  0.172646
 -0.516236  0.203166
 -0.517168  0.222419
 -0.513854  0.239667</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/WeightFunction.jl#L11-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.DiscreteWeightFunction" href="#SpecialPolynomials.DiscreteWeightFunction"><code>SpecialPolynomials.DiscreteWeightFunction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DiscreteWeightFunction</code></pre><p>For a discrete measure, <code>dŒª = ‚àë w·µ¢ Œ¥(x - x·µ¢)</code>, specified through two vectors, <code>xs</code> and <code>ws</code>, a collection of monic orthogonal polynomials is produced through Darboux&#39;s formula for <code>Œ±_n</code> and <code>Œ≤_n</code> using the 3-term recurrence defined by <code>œÄ_{n+1} = (x-Œ±_n)‚ãÖœÄ_n - Œ≤_n‚ãÖœÄ_{n-1}</code> (<code>An=1</code>, <code>Bn=-Œ±_n</code>, <code>Cn=Œ≤_n</code>) and the discrete Stieltjes method <a href="https://www.cs.purdue.edu/homes/wxg/Madrid.pdf">Guatschi ¬ß3.1</a>.</p><p><strong>Example</strong></p><p>Discrete Chebyshev by its weight function (uniform  on 0,1,‚Ä¶,N-1)</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; const SP = SpecialPolynomials;

julia&gt; N = 9
9

julia&gt; xs, ws = collect(0:N-1), ones(N);   # w(x) = ‚àë w‚±º‚ãÖŒ¥(x-x‚±º)

julia&gt; SP.@register0 DWF DiscreteWeightFunction

julia&gt; SP.@register_discrete_weight_function(DWF, xs, ws)

julia&gt; [SP.Bn.(DWF, 0:N-1) SP.Cn.(DWF, 0:N-1)]
9√ó2 Array{Float64,2}:
 -4.0  9.0
 -4.0  6.66667
 -4.0  5.13333
 -4.0  4.62857
 -4.0  4.12698
 -4.0  3.53535
 -4.0  2.83217
 -4.0  2.01026
 -4.0  1.06667

julia&gt; i,j = 3,4; ## check  that ‚à´p·µ¢p‚±ºdw  = 0    for i,j=3,4

julia&gt; sum(basis(DWF,i)(x) *  basis(DWF,j)(x) * w for  (x,w) in zip(xs, ws))
5.684341886080802e-14

julia&gt; ## Gogin, Hirvensalo (https://doi.org/10.1007/s10958-017-3410-8) characterization
       D(k,N,x) =  sum((-1)^l * binomial(k+l,k) * binomial(N-l,k-l) *  SP.generalized_binomial(x,l) for l in 0:k)
D (generic function with 1 method)

julia&gt; x = variable()
Polynomial(x)

julia&gt; ps,qs = [D(k,N-1,x)  for  k in 0:N-1], [basis(DWF, k)(x) for k  in 0:N-1];



julia&gt; all(qs .* [p[end] for p  in ps] .‚âà ps)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Orthogonal/Discrete/discrete-orthogonal.jl#L26-L85">source</a></section></article><h3 id="Interpolating-polynomials"><a class="docs-heading-anchor" href="#Interpolating-polynomials">Interpolating polynomials</a><a id="Interpolating-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.AbstractInterpolatingPolynomial" href="#SpecialPolynomials.AbstractInterpolatingPolynomial"><code>SpecialPolynomials.AbstractInterpolatingPolynomial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractInterpolatingPolynomial{T}</code></pre><p>Abstract type for interpolating polynomials.</p><p>These are polynomial representations of <code>p(x)</code> satisfying <code>p(x_i) = y_i</code> for a specified set of <code>x</code> values and <code>y</code> values.</p><p>For a collection of points <code>(x_0,y_0), ..., (x_n, y_n)</code> there is a <em>unique</em> polynomial of degree <code>n</code> or less satisfying <code>p(x_i)=y_i</code>. This fact allows the specification of <code>p(x)</code> using a vector of coefficients relative to some set of basis vectors.</p><p>The two main types, <code>Lagrange</code> and <code>Newton</code>, store the nodes within the instance. In particular, the type does not contain all the information needed to describe the family. So methods like <code>convert(::Type, p)</code> will not work. Use <code>fit(Type, xs, p)</code>, as appropriate, instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Interpolating/interpolating.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Lagrange" href="#SpecialPolynomials.Lagrange"><code>SpecialPolynomials.Lagrange</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Lagrange{N, S, R, T}</code></pre><p>Represent a polynomial in Lagrange form using nodes <code>xs</code>, weights <code>ws</code>, and coefficients <code>coeffs</code>. The Lagrange form does polynomial interpolation between <code>xs</code> and <code>ys</code> through <code>p(x) = Œ£_{0..n} ‚Ñì_i(x) y_i</code>, where if <code>‚Ñì(x) = prod(x-x_i)</code>, <code>w_i = 1/prod_{j‚â†i}(x_i - x_j)</code>, then <code>‚Ñì_i(x) = ‚Ñì(x) w_i/(x-x_i)</code>. The <code>‚Ñì_i</code> satisfy <code>‚Ñì_i(x_j) = Œ¥_{ij}</code>, so the coefficients are just the <code>ys</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1‚ãÖ‚Ñì^2_0(x) + 2‚ãÖ‚Ñì^2_1(x) + 3‚ãÖ‚Ñì^2_2(x))

julia&gt; p.([1,2,3]) # the coefficients
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; convert(Polynomial,  p)
Polynomial(1.0*x)</code></pre><p>The instances hold the nodes and weights, which are necessary for representation, so the type alone can not be used for functions such as <code>variable</code> or <code>convert(Lagrange, ...)</code>. For the former we can  use an instance, for the latter we can use <code>fit</code>:</p><pre><code class="language-julia-repl">julia&gt; p =  Lagrange([1,2,3], [1,2,3])
Lagrange(1‚ãÖ‚Ñì^2_0(x) + 2‚ãÖ‚Ñì^2_1(x) + 3‚ãÖ‚Ñì^2_2(x))

julia&gt; variable(p)
Lagrange(1‚ãÖ‚Ñì^2_0(x) + 2‚ãÖ‚Ñì^2_1(x) + 3‚ãÖ‚Ñì^2_2(x))

julia&gt; q = Polynomial([0,0,1])
Polynomial(x^2)

julia&gt; qq = fit(Lagrange, p.xs, q)
Lagrange(1‚ãÖ‚Ñì^2_0(x) + 4‚ãÖ‚Ñì^2_1(x) + 9‚ãÖ‚Ñì^2_2(x))

julia&gt; convert(Polynomial, qq)
Polynomial(1.0*x^2)</code></pre><p>Interpolating polynomials suffer from the Runge phenomenon unless the nodes are well chosen. For <code>P=Chebyshvev</code> and <code>P=ChebyshevU</code>, the function <code>SpecialPolynomials.lagrange_barycentric_nodes_weights(P, n)</code> will return a good choice of <code>n+1</code> points over <code>[-1,1]</code> along with precomputed weights. </p><pre><code class="language-julia-repl">julia&gt; xs, ws = SpecialPolynomials.lagrange_barycentric_nodes_weights(Chebyshev, 64);


julia&gt; f(x) = exp(-x)*sinpi(x)
f (generic function with 1 method)

julia&gt; p = fit(Lagrange, xs, f.(xs));


julia&gt; degree(p)
64

julia&gt; maximum(abs.(f(x) - p(x) for x in range(-1, 1, length=20))) &lt;= 1e-14
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The above example  is  more directly  done through <code>fit(Chebyshev, f, 64)</code>, though  the resulting polynomial will reference a different  basis.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Interpolating/Lagrange.jl#L1-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Newton" href="#SpecialPolynomials.Newton"><code>SpecialPolynomials.Newton</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Newton{S,T}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Newton_polynomial">Newton</a> interpolating polynomial uses a basis <code>1</code>, <code>(x-x_0)</code>, <code>(x-x_0)(x-x_1)</code>, ..., <code>(x-x0)(x-x1)‚ãÖ‚ãÖ‚ãÖ(x-x_{n-1})</code> and coefficients (in forward form) <code>f[x_0]</code>, <code>f[x_0,x_1]</code>, ...,<code>f[x_0,...,x_n]</code>. The Newton class stores the nodes (after sorting) and the Newton tableau used to generate the coefficients on fitting.</p><p>The easiest way to construct an instance is with <code>fit</code>, as in:</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; xs = [1,2,3,4]; f(x)= x^3 - 2x + 1;

julia&gt; p = fit(Newton, xs, f)
Newton(5.0‚ãÖp_1(x) + 6.0‚ãÖp_2(x) + 1.0‚ãÖp_3(x))

julia&gt; p.(xs) == f.(xs)  # p interpolates
true

julia&gt; convert(Polynomial, p)
Polynomial(1.0 - 2.0*x + 1.0*x^3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Interpolating/Newton.jl#L1-L28">source</a></section></article><h3 id="Other-polynomials"><a class="docs-heading-anchor" href="#Other-polynomials">Other polynomials</a><a id="Other-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Other-polynomials" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SpecialPolynomials.Bernstein" href="#SpecialPolynomials.Bernstein"><code>SpecialPolynomials.Bernstein</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Bernstein{N, T}</code></pre><p>A <a href="https://en.wikipedia.org/wiki/Bernstein_polynomial">Bernstein  polynomial</a> is a polynomial expressed in terms of Bernstein basic polynomials. For each degree, <code>ùêç</code>, this is a set of <code>ùêç+1</code> degree <code>ùêç</code> polynomials of the form: <code>Œ≤_{ùêç,ŒΩ} =  (ŒΩ choose ùêç) x^ŒΩ  (1-x)^{ùêç-ŒΩ}</code>, <code>0 ‚â§ x ‚â§ 1.</code></p><p>The <code>Bernstein{ùêç,T}</code> type represents a polynomial of degree <code>ùêç</code> or less with a linear combination of the basis vectors using coefficients of type <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; using Polynomials, SpecialPolynomials

julia&gt; p = basis(Bernstein{3},  2)
Bernstein(1.0‚ãÖŒ≤‚ÇÉ,‚ÇÇ(x))

julia&gt; convert(Polynomial, p)
Polynomial(3.0*x^2 - 3.0*x^3)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><a href="https://github.com/tkoolen/StaticUnivariatePolynomials.jl">StaticUnivariatePolynomials</a> Offers a  more  performant version.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jverzani/SpecialPolynomials.jl/blob/76784d0160716e36d1d4bc44daeb62578e262f47/src/Bernstein.jl#L3-L28">source</a></section></article><p>Example of a <a href="https://pomax.github.io/bezierinfo/">Bezier</a> curve  (parameterized by <code>r(t) = ‚àë‚ÇÄ·¥∫ b·µ¢B·µ¢(t)</code>:</p><pre><code class="language-">using Plots, Polynomials, SpecialPolynomials
bs =[[220, 260], [220, 40], [35, 100],  [120, 140]]
N = length(bs)-1

œÅ = sum(b·µ¢.*basis(Bernstein{N},i-1) for (i,b·µ¢)  ‚àà enumerate(bs))
ts = range(0, stop=1, length=500)
p =  plot(œÅ[1].(ts), œÅ[2].(ts), legend=false)
scatter!(p, [b[1] for b in bs], [b[2] for b in bs])
savefig(&quot;bezier.svg&quot;); nothing # hide</code></pre><p><img src="bezier.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="examples/">¬´ Examples</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 6 July 2020 14:23">Monday 6 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
